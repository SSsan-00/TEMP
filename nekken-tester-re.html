<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>NEKKEN: ARCADE MODE</title>
    <style>
      /* スタイル設定 (変更なし) */
      body {
        margin: 0;
        overflow: hidden;
        background-color: #050505;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        font-family: "Segoe UI", sans-serif;
      }

      #game-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 10;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .hud-top {
        display: flex;
        justify-content: space-between;
        padding: 15px;
        background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
      }

      .health-bar-wrapper {
        width: 40%;
        position: relative;
      }

      .health-bar-bg {
        width: 100%;
        height: 20px;
        background: #222;
        border: 2px solid #444;
        transform: skewX(-20deg);
        overflow: hidden;
      }

      .health-bar-fill {
        height: 100%;
        width: 100%;
        transition: width 0.1s linear;
      }

      .hp-p1 {
        background: linear-gradient(90deg, #ff9900, #ffff00);
        float: right;
      }

      .hp-p2 {
        background: linear-gradient(90deg, #ff0055, #ff55aa);
        transform-origin: left;
      }

      .gauge-bar-wrapper {
        width: 100%;
        height: 8px;
        background: #111;
        border: 1px solid #333;
        margin-top: 2px;
        transform: skewX(-20deg);
      }

      .gauge-bar-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #00ffff, #0088ff);
        box-shadow: 0 0 5px #00ffff;
        transition: width 0.1s linear;
      }

      .name-label {
        color: #fff;
        font-size: 14px;
        font-weight: bold;
        margin-top: 5px;
        text-shadow: 0 0 5px #00ffff;
        letter-spacing: 1px;
      }

      .round-badge {
        color: #00ffff;
        font-size: 24px;
        font-weight: 900;
        text-shadow: 0 0 10px #00ffff;
        text-align: center;
      }

      #controls-area {
        position: absolute;
        bottom: 20px;
        width: 100%;
        height: 180px;
        pointer-events: none;
        display: flex;
        justify-content: space-between;
        padding: 0 20px;
        box-sizing: border-box;
      }

      .control-zone {
        pointer-events: auto;
        position: relative;
      }

      #joystick-zone {
        width: 150px;
        height: 150px;
      }

      #stick-base {
        width: 120px;
        height: 120px;
        background: rgba(0, 255, 255, 0.1);
        border: 2px solid rgba(0, 255, 255, 0.3);
        border-radius: 50%;
        position: absolute;
        bottom: 10px;
        left: 10px;
      }

      #stick-knob {
        width: 50px;
        height: 50px;
        background: rgba(0, 255, 255, 0.5);
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        box-shadow: 0 0 10px #00ffff;
      }

      #action-zone {
        width: 180px;
        height: 150px;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 5px;
      }

      .btn-action {
        border-radius: 50%;
        background: rgba(255, 0, 85, 0.2);
        border: 2px solid rgba(255, 0, 85, 0.5);
        color: #fff;
        font-weight: bold;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: manipulation;
        transition: transform 0.1s, background 0.1s;
        text-align: center;
        line-height: 1.1;
      }

      .btn-action:active,
      .btn-action.pressed {
        background: rgba(255, 0, 85, 0.6);
        transform: scale(0.95);
      }

      .btn-action.disabled {
        background: rgba(50, 50, 50, 0.5) !important;
        border-color: #555 !important;
        color: #888 !important;
        pointer-events: none;
        filter: grayscale(100%);
        opacity: 0.6;
      }

      #btn-atk {
        grid-column: 3;
        grid-row: 2;
        width: 65px;
        height: 65px;
        align-self: end;
        justify-self: end;
      }

      #btn-jump {
        grid-column: 2;
        grid-row: 2;
        width: 50px;
        height: 50px;
        align-self: end;
        margin-bottom: 10px;
      }

      #btn-sp {
        grid-column: 3;
        grid-row: 1;
        width: 45px;
        height: 45px;
        align-self: end;
        border-color: #ffff00;
        color: #ffff00;
        background: rgba(255, 255, 0, 0.2);
      }

      #btn-ult {
        grid-column: 2;
        grid-row: 1;
        width: 45px;
        height: 45px;
        align-self: end;
        border-color: #ff00ff;
        color: #ff00ff;
        background: rgba(255, 0, 255, 0.2);
        box-shadow: 0 0 5px #ff00ff;
      }

      #btn-dash {
        grid-column: 1;
        grid-row: 2;
        width: 50px;
        height: 50px;
        align-self: end;
        border-color: #00ff00;
        color: #00ff00;
        background: rgba(0, 255, 0, 0.2);
      }

      #btn-guard {
        grid-column: 1;
        grid-row: 1;
        width: 45px;
        height: 45px;
        align-self: end;
        border-color: #0088ff;
        color: #0088ff;
        background: rgba(0, 136, 255, 0.2);
      }

      .screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(5, 5, 10, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        z-index: 20;
        transition: opacity 0.5s;
      }

      h1 {
        color: #fff;
        font-size: 40px;
        letter-spacing: 5px;
        border-bottom: 2px solid #00ffff;
        margin-bottom: 20px;
        text-shadow: 0 0 20px #00ffff;
        text-align: center;
      }

      .btn-cyber {
        background: rgba(0, 255, 255, 0.1);
        border: 1px solid #00ffff;
        color: #00ffff;
        padding: 15px 40px;
        font-size: 20px;
        font-weight: bold;
        cursor: pointer;
        letter-spacing: 2px;
        margin: 10px;
        clip-path: polygon(
          10px 0,
          100% 0,
          100% calc(100% - 10px),
          calc(100% - 10px) 100%,
          0 100%,
          0 10px
        );
        transition: all 0.2s;
      }

      .btn-cyber:hover {
        background: rgba(0, 255, 255, 0.3);
        box-shadow: 0 0 15px #00ffff;
      }

      .btn-cyber:active {
        background: #00ffff;
        color: #000;
      }

      #select-screen {
        background: linear-gradient(135deg, #050510 0%, #1a1a2e 100%);
        overflow-y: auto;
      }

      #select-screen h2 {
        font-size: 32px;
        color: #00ffff;
        text-shadow: 0 0 10px #00ffff;
        letter-spacing: 4px;
        margin-bottom: 20px;
        text-transform: uppercase;
        border-bottom: 2px solid #00ffff;
        padding-bottom: 10px;
        margin-top: 40px;
      }

      .char-grid {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 25px;
        max-width: 900px;
        width: 100%;
        padding: 20px;
        padding-bottom: 50px;
        scrollbar-width: thin;
        scrollbar-color: #00ffff #111;
      }

      .char-card {
        background: rgba(20, 20, 30, 0.8);
        border: 1px solid #444;
        border-left: 4px solid #444;
        border-radius: 4px;
        padding: 15px;
        text-align: center;
        color: #fff;
        cursor: pointer;
        width: 160px;
        transition: all 0.3s;
        position: relative;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
      }

      .char-card:hover {
        transform: translateY(-5px) scale(1.05);
        border-color: #00ffff;
        border-left-color: #00ffff;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
        background: rgba(0, 40, 40, 0.8);
      }

      .char-card.active {
        border-color: #ff0055;
        border-left-color: #ff0055;
        background: rgba(40, 0, 20, 0.9);
        box-shadow: 0 0 30px rgba(255, 0, 85, 0.6);
        transform: scale(1.1);
        z-index: 10;
      }

      .char-preview-box {
        width: 80px;
        height: 80px;
        margin: 0 auto 15px;
        border-radius: 50%;
        border: 3px solid #fff;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        position: relative;
        background-color: #000;
        transition: 0.3s;
      }

      .char-name {
        font-size: 16px;
        font-weight: bold;
        margin-bottom: 10px;
        letter-spacing: 1px;
        text-transform: uppercase;
        white-space: nowrap;
      }

      .stat-row {
        display: flex;
        align-items: center;
        margin: 4px 0;
        font-size: 10px;
        color: #aaa;
        font-family: monospace;
      }

      .stat-label {
        width: 25px;
        text-align: left;
        font-weight: bold;
      }

      .stat-bar-bg {
        flex-grow: 1;
        height: 4px;
        background: #333;
        border-radius: 2px;
        overflow: hidden;
      }

      .stat-bar-fill {
        height: 100%;
        width: 0%;
        transition: width 0.5s ease-out;
      }

      .pwr-fill {
        background: linear-gradient(90deg, #ff5500, #ffaa00);
      }

      .spd-fill {
        background: linear-gradient(90deg, #0088ff, #00ffff);
      }

      @media (max-width: 600px) {
        .char-grid {
          padding: 10px;
          gap: 15px;
          padding-bottom: 80px;
        }

        .char-card {
          width: 42%;
          padding: 10px;
        }

        .char-preview-box {
          width: 60px;
          height: 60px;
          margin-bottom: 10px;
        }

        .char-name {
          font-size: 12px;
          margin-bottom: 5px;
        }

        #select-screen h2 {
          font-size: 24px;
          margin-top: 20px;
        }
      }

      #kb-hint {
        position: absolute;
        bottom: 10px;
        left: 0;
        width: 100%;
        text-align: center;
        color: #666;
        font-size: 10px;
        pointer-events: none;
        display: none;
      }

      .hidden {
        display: none !important;
      }

      /* ====== SELF TEST 結果表示用 ====== */
      .test-panel {
        max-width: 600px;
        width: 90%;
        margin: 10px auto;
        padding: 10px 15px;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #333;
        border-radius: 4px;
        color: #ddd;
        font-size: 12px;
        line-height: 1.4;
        text-align: left;
      }

      .test-summary-ok {
        color: #00ff99;
        font-weight: bold;
      }

      .test-summary-fail {
        color: #ff5555;
        font-weight: bold;
      }

      .test-item-ok {
        color: #88ff88;
      }

      .test-item-fail {
        color: #ff8888;
      }

      .test-item-name {
        font-weight: bold;
      }

      .test-item-message {
        margin-left: 1em;
        font-family: monospace;
        white-space: pre-wrap;
      }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  </head>

  <body>
    <div id="game-container"></div>
    <div id="ui-layer">
      <div class="hud-top" id="hud" style="display: none">
        <div class="health-bar-wrapper">
          <div class="health-bar-bg">
            <div id="p1-hp" class="health-bar-fill hp-p1"></div>
          </div>
          <div class="gauge-bar-wrapper">
            <div id="p1-gauge" class="gauge-bar-fill"></div>
          </div>
          <div class="name-label" style="text-align: right">YOU</div>
        </div>
        <div class="round-badge">
          <div id="round-display">VS</div>
          <div id="level-display" style="font-size: 12px; color: #aaa">
            Lv.1
          </div>
        </div>
        <div class="health-bar-wrapper">
          <div class="health-bar-bg">
            <div id="p2-hp" class="health-bar-fill hp-p2"></div>
          </div>
          <div class="gauge-bar-wrapper">
            <div id="p2-gauge" class="gauge-bar-fill"></div>
          </div>
          <div class="name-label" id="enemy-name">CPU</div>
        </div>
      </div>
      <div id="controls-area" style="display: none">
        <div class="control-zone" id="joystick-zone">
          <div id="stick-base">
            <div id="stick-knob"></div>
          </div>
        </div>
        <div class="control-zone" id="action-zone">
          <div class="btn-action" id="btn-guard">GRD<br />(C)</div>
          <div class="btn-action" id="btn-ult">ULT<br />(V)</div>
          <div class="btn-action" id="btn-sp">SP<br />(X)</div>
          <div class="btn-action" id="btn-dash">DSH<br />(Sft)</div>
          <div class="btn-action" id="btn-jump">JMP<br />(Spc)</div>
          <div class="btn-action" id="btn-atk">ATK<br />(Z)</div>
        </div>
      </div>
      <div id="kb-hint">
        PC操作: 矢印=移動 | Z=攻撃 | X=必殺 | C=ガード | Shift=ダッシュ |
        Space=ジャンプ | V=ULT
      </div>
    </div>

    <!-- ★ セルフテスト結果表示用画面 -->
    <div id="test-screen" class="screen">
      <h1 style="font-size: 28px">SELF TEST</h1>

      <!-- テストの概要（成功数・失敗数など） -->
      <div id="test-summary" class="test-panel">Running self test...</div>

      <!-- テストごとの詳細 -->
      <div id="test-detail" class="test-panel">
        <!-- テスト結果がここに挿入される -->
      </div>

      <!-- すべて成功したときだけ表示されるボタン -->
      <button id="test-continue-btn" class="btn-cyber hidden">CONTINUE</button>

      <!-- ★ 開発者用：テスト失敗しててもゲームを強制起動するボタン -->
      <button
        id="test-force-btn"
        class="btn-cyber hidden"
        style="
          margin-top: 10px;
          font-size: 14px;
          background: rgba(255, 0, 0, 0.1);
          border-color: #ff5555;
          color: #ff8888;
        "
      >
        FORCE START (DEV)
      </button>
    </div>
    <div id="title-screen" class="screen">
      <h1>
        NEKKEN<br /><span style="font-size: 20px; letter-spacing: 2px"
          >REALISTIC MODE</span
        >
      </h1>
      <button id="start-btn" class="btn-cyber">MISSION START</button>
    </div>
    <div id="select-screen" class="screen hidden">
      <h2>SELECT YOUR CHASSIS</h2>
      <div class="char-grid" id="char-grid"></div>
    </div>
    <div id="result-screen" class="screen hidden">
      <h1 id="result-msg">WIN</h1>
      <button id="retry-btn" class="btn-cyber">NEXT STAGE</button>
    </div>

    <script>
      const Input = {
        x: 0,
        y: 0,
        attack: false,
        jump: false,
        special: false,
        dash: false,
        guard: false,
        ultimate: false,
        keys: {},
        stick: {
          active: false,
          startX: 0,
          startY: 0,
          currX: 0,
          currY: 0,
          maxDist: 40,
        },
        init: function () {
          window.addEventListener("keydown", (e) => {
            this.keys[e.code] = true;
            if (e.code === "KeyZ") this.attack = true;
            if (e.code === "KeyX") this.special = true;
            if (e.code === "Space") this.jump = true;
            if (e.code === "ShiftLeft" || e.code === "ShiftRight")
              this.dash = true;
            if (e.code === "KeyC") this.guard = true;
            if (e.code === "KeyV") this.ultimate = true;
          });
          window.addEventListener("keyup", (e) => {
            this.keys[e.code] = false;
            if (e.code === "KeyZ") this.attack = false;
            if (e.code === "KeyX") this.special = false;
            if (e.code === "Space") this.jump = false;
            if (e.code === "ShiftLeft" || e.code === "ShiftRight")
              this.dash = false;
            if (e.code === "KeyC") this.guard = false;
            if (e.code === "KeyV") this.ultimate = false;
          });
          if (!("ontouchstart" in window))
            document.getElementById("kb-hint").style.display = "block";
          const stickBase = document.getElementById("stick-base"),
            stickKnob = document.getElementById("stick-knob"),
            zone = document.getElementById("joystick-zone");
          const handleMove = (clientX, clientY) => {
            if (!this.stick.active) return;
            const rect = stickBase.getBoundingClientRect(),
              centerX = rect.left + rect.width / 2,
              centerY = rect.top + rect.height / 2;
            let dx = clientX - centerX,
              dy = clientY - centerY,
              dist = Math.hypot(dx, dy);
            if (dist > this.stick.maxDist) {
              const r = this.stick.maxDist / dist;
              dx *= r;
              dy *= r;
            }
            stickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            this.x = dx / this.stick.maxDist;
            this.y = dy / this.stick.maxDist;
          };
          const resetStick = () => {
            this.stick.active = false;
            this.x = 0;
            this.y = 0;
            stickKnob.style.transform = `translate(-50%, -50%)`;
          };
          zone.addEventListener(
            "touchstart",
            (e) => {
              e.preventDefault();
              this.stick.active = true;
              handleMove(e.touches[0].clientX, e.touches[0].clientY);
            },
            { passive: false }
          );
          zone.addEventListener(
            "touchmove",
            (e) => {
              e.preventDefault();
              handleMove(e.touches[0].clientX, e.touches[0].clientY);
            },
            { passive: false }
          );
          zone.addEventListener("touchend", resetStick);
          zone.addEventListener("mousedown", (e) => {
            this.stick.active = true;
            handleMove(e.clientX, e.clientY);
          });
          window.addEventListener("mousemove", (e) => {
            if (this.stick.active) handleMove(e.clientX, e.clientY);
          });
          window.addEventListener("mouseup", resetStick);
          const bindBtn = (id, prop) => {
            const el = document.getElementById(id);
            const press = (e) => {
              if (e.type === "touchstart") e.preventDefault();
              this[prop] = true;
              el.classList.add("pressed");
            };
            const release = (e) => {
              if (e.type === "touchend") e.preventDefault();
              this[prop] = false;
              el.classList.remove("pressed");
            };
            el.addEventListener("touchstart", press, { passive: false });
            el.addEventListener("touchend", release);
            el.addEventListener("mousedown", press);
            el.addEventListener("mouseup", release);
            el.addEventListener("mouseleave", release);
            el.addEventListener("touchcancel", release);
          };
          bindBtn("btn-atk", "attack");
          bindBtn("btn-jump", "jump");
          bindBtn("btn-sp", "special");
          bindBtn("btn-dash", "dash");
          bindBtn("btn-guard", "guard");
          bindBtn("btn-ult", "ultimate");
          window.addEventListener("touchend", (e) => {
            if (e.touches.length === 0) this.reset();
          });
        },
        reset: function () {
          this.x = 0;
          this.y = 0;
          this.attack = false;
          this.jump = false;
          this.special = false;
          this.dash = false;
          this.guard = false;
          this.ultimate = false;
          this.stick.active = false;
          document
            .querySelectorAll(".btn-action")
            .forEach((b) => b.classList.remove("pressed"));
          const k = document.getElementById("stick-knob");
          if (k) k.style.transform = `translate(-50%, -50%)`;
        },
        update: function () {
          let kx = 0,
            ky = 0;
          if (this.keys["ArrowLeft"]) kx -= 1;
          if (this.keys["ArrowRight"]) kx += 1;
          if (this.keys["ArrowUp"]) ky -= 1;
          if (this.keys["ArrowDown"]) ky += 1;
          if (!this.stick.active) {
            this.x = kx;
            this.y = ky;
          }
        },
      };

      const GAME_STATE = { TITLE: 0, SELECT: 1, FIGHT: 2, END: 3 };
      let currentState = GAME_STATE.TITLE;
      let scene, camera, renderer, clock;
      let player, enemy;
      let particles = [],
        projectiles = [];
      let currentLevel = 0,
        retryCredits = 3;
      let floorMesh; // 背景変更用にグローバル化

      const PLAYER_CATS = [
        {
          name: "VORTEX",
          color: 0x221111,
          trim: 0xff8800,
          eye: 0xffd700,
          socks: false,
          pattern: "sabi",
          speed: 1.0,
          power: 1.3,
          hpMulti: 1.1,
        },
        {
          name: "BLADE",
          color: 0xbbbbbb,
          trim: 0x111111,
          eye: 0xdfff00,
          socks: true,
          pattern: "stripe",
          speed: 1.4,
          power: 0.9,
          hpMulti: 0.9,
        },
        {
          name: "CHROME",
          color: 0xffffff,
          trim: 0x00ffff,
          eye: 0x00ffff,
          socks: false,
          pattern: "solid",
          speed: 1.0,
          power: 1.0,
          hpMulti: 1.0,
        },
        {
          name: "SHADOW",
          color: 0x111111,
          trim: 0x5500ff,
          eye: 0xff0000,
          socks: true,
          pattern: "solid",
          speed: 1.2,
          power: 0.9,
          hpMulti: 0.9,
        },
      ];
      const ENEMY_CATS = [
        {
          name: "LV1: STRAY",
          color: 0x888888,
          trim: 0xaaaaaa,
          eye: 0x00ff00,
          socks: false,
          pattern: "solid",
          speed: 0.8,
          power: 0.7,
          hpMulti: 0.8,
          aiLevel: 1,
        },
        {
          name: "LV2: GINGER",
          color: 0xffcc88,
          trim: 0xcc6600,
          eye: 0xffff00,
          socks: true,
          pattern: "stripe",
          speed: 0.9,
          power: 0.8,
          hpMulti: 0.9,
          aiLevel: 2,
        },
        {
          name: "LV3: MOSS",
          color: 0x224422,
          trim: 0x44ff44,
          eye: 0x00ff00,
          socks: false,
          pattern: "sabi",
          speed: 1.0,
          power: 1.0,
          hpMulti: 1.0,
          aiLevel: 3,
        },
        {
          name: "LV4: AQUA",
          color: 0x004488,
          trim: 0x00ffff,
          eye: 0x00ffff,
          socks: true,
          pattern: "solid",
          speed: 1.1,
          power: 1.0,
          hpMulti: 1.0,
          aiLevel: 4,
        },
        {
          name: "LV5: VOLT",
          color: 0xffff00,
          trim: 0x222222,
          eye: 0xff0000,
          socks: false,
          pattern: "stripe",
          speed: 1.4,
          power: 1.1,
          hpMulti: 1.2,
          aiLevel: 5,
        },
        {
          name: "LV6: MAGMA",
          color: 0x440000,
          trim: 0xff4400,
          eye: 0xffaa00,
          socks: false,
          pattern: "sabi",
          speed: 1.1,
          power: 1.6,
          hpMulti: 1.2,
          aiLevel: 6,
        },
        {
          name: "LV7: PHANTOM",
          color: 0x220033,
          trim: 0xff00ff,
          eye: 0xff00ff,
          socks: true,
          pattern: "stripe",
          speed: 1.4,
          power: 1.3,
          hpMulti: 1.3,
          aiLevel: 7,
        },
        {
          name: "LV8: BLADE-X",
          color: 0xaaaaaa,
          trim: 0x000000,
          eye: 0x00ffcc,
          socks: true,
          pattern: "stripe",
          speed: 1.6,
          power: 1.3,
          hpMulti: 1.3,
          aiLevel: 8,
        },
        {
          name: "LV9: VORTEX-Z",
          color: 0x110000,
          trim: 0xffaa00,
          eye: 0xff0000,
          socks: false,
          pattern: "sabi",
          speed: 1.3,
          power: 1.6,
          hpMulti: 1.4,
          aiLevel: 9,
          infiniteBeams: true,
        },
        {
          name: "LV10: GENESIS",
          color: 0xffffff,
          trim: 0xd4af37,
          eye: 0xffffff,
          socks: true,
          pattern: "sabi",
          speed: 1.5,
          power: 1.8,
          hpMulti: 1.6,
          aiLevel: 10,
          infiniteBeams: true,
        },
      ];
      let playerIdx = 0;

      const AudioSys = {
        ctx: null,
        bgmOscillators: [],
        bgmInterval: null,
        init: function () {
          if (!this.ctx)
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        },
        playTone: function (freq, type, dur, vol = 0.1) {
          if (!this.ctx) return;
          const t = this.ctx.currentTime;
          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, t);
          osc.frequency.exponentialRampToValueAtTime(freq * 0.1, t + dur);
          g.gain.setValueAtTime(vol, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + dur);
          osc.connect(g);
          g.connect(this.ctx.destination);
          osc.start();
          osc.stop(t + dur);
        },
        meow: function (isPain = false) {
          if (!this.ctx) return;
          const t = this.ctx.currentTime;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          osc.type = "sawtooth";
          filter.type = "lowpass";
          filter.frequency.value = 1000;
          const startFreq = isPain
            ? 500 + Math.random() * 200
            : 300 + Math.random() * 150;
          const duration = isPain ? 0.2 : 0.4 + Math.random() * 0.3;
          osc.frequency.setValueAtTime(startFreq, t);
          osc.frequency.linearRampToValueAtTime(
            startFreq * 1.5,
            t + duration * 0.3
          );
          osc.frequency.linearRampToValueAtTime(startFreq * 0.8, t + duration);
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.1, t + duration * 0.1);
          gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.ctx.destination);
          osc.start(t);
          osc.stop(t + duration);
        },
        // ① BGM機能の実装
        stopBGM: function () {
          if (this.bgmInterval) {
            clearInterval(this.bgmInterval);
            this.bgmInterval = null;
          }
          this.bgmOscillators.forEach((o) => {
            try {
              o.stop();
            } catch (e) {}
          });
          this.bgmOscillators = [];
        },
        playBGM: function (level) {
          this.stopBGM();
          if (!this.ctx) return;

          // レベルに基づいてBPMと雰囲気パラメータを決定
          const bpm = 140 + level * 5;
          const interval = 60000 / bpm / 4; // 16分音符

          let step = 0;
          let patternType = 0; // 0:Grass, 1:Concrete/Desert, 2:Sea, 3:Magma
          if (level < 2) patternType = 0;
          else if (level < 6) patternType = 1;
          else if (level < 8) patternType = 2;
          else patternType = 3;

          // ベース音色
          const bassOscType =
            patternType === 3
              ? "sawtooth"
              : patternType === 2
              ? "sine"
              : "square";
          const scale = [55, 65.4, 73.4, 82.4]; // A, C, D, E (Simple Pentatonic-ish)

          this.bgmInterval = setInterval(() => {
            const t = this.ctx.currentTime;

            // Bass Line
            if (step % 4 === 0 || (patternType === 3 && step % 2 === 0)) {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = bassOscType;

              // プロシージャルなベースライン生成
              const noteIdx =
                (Math.floor(step / 4) + (step % 3)) % scale.length;
              let freq = scale[noteIdx];
              if (patternType === 3) freq *= 0.5; // マグマは重低音

              osc.frequency.setValueAtTime(freq, t);
              osc.frequency.exponentialRampToValueAtTime(freq * 0.5, t + 0.1);

              gain.gain.setValueAtTime(0.1, t);
              gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);

              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start(t);
              osc.stop(t + 0.2);
            }

            // Drum / Hi-hat (White Noise buffer)
            if (step % 2 === 0) {
              // Hi-hat every 8th note
              const bufferSize = this.ctx.sampleRate * 0.05;
              const buffer = this.ctx.createBuffer(
                1,
                bufferSize,
                this.ctx.sampleRate
              );
              const data = buffer.getChannelData(0);
              for (let i = 0; i < bufferSize; i++)
                data[i] = Math.random() * 2 - 1;

              const noise = this.ctx.createBufferSource();
              noise.buffer = buffer;
              const filter = this.ctx.createBiquadFilter();
              filter.type = "highpass";
              filter.frequency.value = 5000;
              const gain = this.ctx.createGain();

              const vol = step % 4 === 2 ? 0.05 : 0.02; // 裏拍で強調
              gain.gain.setValueAtTime(vol, t);
              gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

              noise.connect(filter);
              filter.connect(gain);
              gain.connect(this.ctx.destination);
              noise.start(t);
            }

            // Kick (Synth)
            if (step % 4 === 0) {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = "sine";
              osc.frequency.setValueAtTime(150, t);
              osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
              gain.gain.setValueAtTime(0.3, t);
              gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start(t);
              osc.stop(t + 0.1);
            }

            // Arpeggio / Melody (Levelが高くなると激しくなる)
            if (patternType > 0 && Math.random() < 0.2 + level * 0.05) {
              const osc = this.ctx.createOscillator();
              const gain = this.ctx.createGain();
              osc.type = "triangle";
              const mFreq = scale[Math.floor(Math.random() * scale.length)] * 4;
              osc.frequency.setValueAtTime(mFreq, t);
              gain.gain.setValueAtTime(0.05, t);
              gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
              osc.connect(gain);
              gain.connect(this.ctx.destination);
              osc.start(t);
              osc.stop(t + 0.1);
            }

            step = (step + 1) % 16;
          }, interval);
        },
        hit: () => AudioSys.playTone(150, "square", 0.2, 0.2),
        swing: () => AudioSys.playTone(400, "sawtooth", 0.1, 0.05),
        jump: () => AudioSys.playTone(300, "sine", 0.2, 0.1),
        beam: () => AudioSys.playTone(600, "square", 0.3, 0.1),
        dash: () => AudioSys.playTone(200, "triangle", 0.1, 0.1),
        ultimate: () => AudioSys.playTone(800, "square", 1.0, 0.3),
      };

      function init3D() {
        const container = document.getElementById("game-container");
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        scene.fog = new THREE.FogExp2(0x0a0a12, 0.04);
        camera = new THREE.PerspectiveCamera(
          45,
          container.clientWidth / container.clientHeight,
          0.1,
          100
        );
        camera.position.set(0, 6, 14);
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          powerPreference: "high-performance",
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
        const amb = new THREE.AmbientLight(0x404040, 2.0);
        scene.add(amb);
        const dir = new THREE.DirectionalLight(0xffffff, 1.2);
        dir.position.set(5, 10, 5);
        dir.castShadow = true;
        scene.add(dir);
        const grid = new THREE.GridHelper(40, 40, 0x00ffff, 0x222222);
        scene.add(grid);

        // 床の初期化 (後でテクスチャ差し替え)
        const planeGeo = new THREE.PlaneGeometry(100, 100);
        const planeMat = new THREE.MeshStandardMaterial({
          color: 0x222222,
          roughness: 0.8,
        });
        floorMesh = new THREE.Mesh(planeGeo, planeMat);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = -0.1;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);

        clock = new THREE.Clock();
        window.addEventListener("resize", () => {
          camera.aspect = container.clientWidth / container.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(container.clientWidth, container.clientHeight);
        });
      }

      // ② テクスチャマッピングによる床の生成
      function updateStageFloor(level) {
        let type = "grass";
        if (level < 2) type = "grass";
        else if (level < 4) type = "concrete";
        else if (level < 6) type = "desert";
        else if (level < 8) type = "sea";
        else type = "magma";

        const size = 512;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");

        // ベースカラー
        if (type === "grass") ctx.fillStyle = "#2dda27";
        else if (type === "concrete") ctx.fillStyle = "#ffffff";
        else if (type === "desert") ctx.fillStyle = "#f2f240";
        else if (type === "sea") ctx.fillStyle = "#006ea2";
        else if (type === "magma") ctx.fillStyle = "#330000";
        ctx.fillRect(0, 0, size, size);

        // ノイズ・模様描画
        for (let i = 0; i < 3000; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const len = 5 + Math.random() * 10;

          ctx.beginPath();
          if (type === "grass") {
            ctx.strokeStyle = "#3e7e38";
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - len);
          } else if (type === "concrete") {
            ctx.fillStyle = Math.random() < 0.5 ? "#444" : "#666";
            ctx.fillRect(x, y, 2, 2);
          } else if (type === "desert") {
            ctx.strokeStyle = "#d4c490";
            ctx.moveTo(x, y);
            ctx.lineTo(x + len, y + Math.sin(x * 0.1) * 5);
          } else if (type === "sea") {
            ctx.strokeStyle = "#004488";
            ctx.lineWidth = 2;
            ctx.moveTo(x, y);
            ctx.lineTo(x + len * 2, y);
          } else if (type === "magma") {
            if (Math.random() < 0.1) {
              ctx.strokeStyle = "#ff3300";
              ctx.lineWidth = 2;
              ctx.moveTo(x, y);
              ctx.lineTo(x + len, y + len);
            }
          }
          ctx.stroke();
        }

        // マグマ用のひび割れ
        if (type === "magma") {
          ctx.strokeStyle = "#ffaa00";
          ctx.lineWidth = 3;
          ctx.shadowBlur = 10;
          ctx.shadowColor = "#ff0000";
          for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            let cx = Math.random() * size;
            let cy = Math.random() * size;
            ctx.moveTo(cx, cy);
            for (let j = 0; j < 20; j++) {
              cx += (Math.random() - 0.5) * 50;
              cy += (Math.random() - 0.5) * 50;
              ctx.lineTo(cx, cy);
            }
            ctx.stroke();
          }
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(10, 10);

        floorMesh.material.map = texture;
        floorMesh.material.needsUpdate = true;

        // 環境光の色も少し調整
        if (type === "magma") scene.fog.color.setHex(0x330000);
        else if (type === "sea") scene.fog.color.setHex(0x001133);
        else scene.fog.color.setHex(0x0a0a12);
      }

      function createCatTexture(baseColorHex, trimColorHex, patternType) {
        const size = 512;
        const canvas = document.createElement("canvas");
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");
        const baseColor = new THREE.Color(baseColorHex);
        const trimColor = new THREE.Color(trimColorHex);

        function drawFurNoise(ctx, color, density, opacity) {
          ctx.fillStyle = color;
          for (let i = 0; i < density; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const len = 2 + Math.random() * 4;
            const angle = (Math.random() - 0.5) * 0.5;
            ctx.globalAlpha = Math.random() * opacity;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.sin(angle) * len, y + Math.cos(angle) * len);
            ctx.strokeStyle = color;
            ctx.lineWidth = 0.5 + Math.random();
            ctx.stroke();
          }
          ctx.globalAlpha = 1.0;
        }

        ctx.fillStyle = `#${baseColor.getHexString()}`;
        ctx.fillRect(0, 0, size, size);

        drawFurNoise(ctx, "#000000", 20000, 0.1);
        drawFurNoise(ctx, "#ffffff", 20000, 0.1);

        if (patternType === "stripe") {
          const cHex = `#${trimColor.getHexString()}`;
          for (let i = 0; i < 15; i++) {
            const basePathY = i * (size / 12);
            for (let x = 0; x < size; x += 2) {
              const yOffset = Math.sin(x * 0.02 + i) * 30 + Math.random() * 5;
              const width = 10 + Math.sin(x * 0.05) * 5;
              if (Math.random() > 0.3) {
                ctx.strokeStyle = cHex;
                ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                ctx.lineWidth = 1;
                ctx.beginPath();
                const furY =
                  basePathY + yOffset + (Math.random() - 0.5) * width;
                ctx.moveTo(x, furY);
                ctx.lineTo(
                  x + (Math.random() - 0.5) * 2,
                  furY + 5 + Math.random() * 5
                );
                ctx.stroke();
              }
            }
          }
        } else if (patternType === "sabi") {
          const cHex = `#${trimColor.getHexString()}`;
          for (let i = 0; i < 60; i++) {
            const cx = Math.random() * size;
            const cy = Math.random() * size;
            const r = 20 + Math.random() * 50;
            for (let j = 0; j < 300; j++) {
              const ang = Math.random() * Math.PI * 2;
              const dist = Math.random() * r;
              const px = cx + Math.cos(ang) * dist;
              const py = cy + Math.sin(ang) * dist;
              ctx.strokeStyle = cHex;
              ctx.globalAlpha = 0.4 + Math.random() * 0.4;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(px, py);
              ctx.lineTo(px, py + 4 + Math.random() * 4);
              ctx.stroke();
            }
          }
        }

        if (patternType !== "solid") {
          drawFurNoise(ctx, `#${trimColor.getHexString()}`, 5000, 0.05);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 1);
        return texture;
      }

      class Cat {
        constructor(data, isPlayer, startZ) {
          this.data = data;
          this.isPlayer = isPlayer;
          this.maxHp = 100 * data.hpMulti;
          this.hp = this.maxHp;
          this.maxGauge = 100;
          this.gauge = 0;
          this.beamCount = 3;
          this.state = "idle";
          this.timer = 0;
          this.vy = 0;
          this.groundY = 0;
          this.invincible = 0;
          this.hasHit = false;
          this.dashVec = new THREE.Vector3();
          this.comboReady = false;
          this.forceApproach = false;
          this.consecutiveShots = 0;
          this.meowTimer = Math.random() * 5 + 3;

          this.mesh = new THREE.Group();
          this.mesh.position.set(0, 0, startZ);

          this.modelGroup = new THREE.Group();
          this.modelGroup.rotation.y = Math.PI;
          this.mesh.add(this.modelGroup);

          const texture = createCatTexture(data.color, data.trim, data.pattern);
          const bodyMat = new THREE.MeshStandardMaterial({
            map: texture,
            roughness: 0.6,
            metalness: 0.1,
          });
          const trimMat = new THREE.MeshStandardMaterial({
            color: data.trim,
            roughness: 0.8,
          });
          const eyeColorMat = new THREE.MeshBasicMaterial({ color: data.eye });
          const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
          const socksMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.8,
          });
          const noseMat = new THREE.MeshStandardMaterial({
            color: 0xffaaaa,
            roughness: 0.5,
          });
          const whiskerMat = new THREE.LineBasicMaterial({
            color: 0xcccccc,
            transparent: true,
            opacity: 0.6,
          });

          this.hips = new THREE.Group();
          this.hips.position.y = 0.55;
          this.modelGroup.add(this.hips);

          const abdomenGeo = new THREE.SphereGeometry(0.28, 16, 12);
          abdomenGeo.scale(1, 0.9, 1.2);
          this.abdomen = new THREE.Mesh(abdomenGeo, bodyMat);
          this.abdomen.position.z = 0.2;
          this.abdomen.castShadow = true;
          this.hips.add(this.abdomen);

          const chestGeo = new THREE.SphereGeometry(0.32, 16, 12);
          chestGeo.scale(1, 0.95, 1.1);
          this.chest = new THREE.Mesh(chestGeo, bodyMat);
          this.chest.position.set(0, 0.05, -0.45);
          this.chest.castShadow = true;
          this.abdomen.add(this.chest);

          this.headGroup = new THREE.Group();
          this.headGroup.position.set(0, 0.25, -0.4);
          this.chest.add(this.headGroup);

          const headGeo = new THREE.SphereGeometry(0.24, 16, 16);
          headGeo.scale(1.1, 0.9, 1.0);
          this.head = new THREE.Mesh(headGeo, bodyMat);
          this.headGroup.add(this.head);

          const muzzleGeo = new THREE.SphereGeometry(0.12, 12, 8);
          muzzleGeo.scale(1, 0.8, 1);
          const muzzle = new THREE.Mesh(muzzleGeo, trimMat);
          muzzle.position.set(0, -0.08, -0.18);
          this.head.add(muzzle);

          const noseGeo = new THREE.ConeGeometry(0.03, 0.05, 3);
          const nose = new THREE.Mesh(noseGeo, noseMat);
          nose.rotation.x = -Math.PI / 2;
          nose.rotation.z = Math.PI;
          nose.position.set(0, 0.08, -0.1);
          muzzle.add(nose);

          const whiskerGroup = new THREE.Group();
          muzzle.add(whiskerGroup);
          for (let i = 0; i < 6; i++) {
            const isRight = i < 3;
            const points = [
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(isRight ? 0.3 : -0.3, (i % 3) * 0.05 - 0.05, 0),
            ];
            const wGeo = new THREE.BufferGeometry().setFromPoints(points);
            const whisker = new THREE.Line(wGeo, whiskerMat);
            whisker.position.set(isRight ? 0.05 : -0.05, 0, -0.05);
            whiskerGroup.add(whisker);
          }

          const eyeGeo = new THREE.SphereGeometry(0.06, 12, 8);
          eyeGeo.scale(1, 1, 0.5);

          const eyeLGroup = new THREE.Group();
          eyeLGroup.position.set(-0.1, 0.02, -0.18);
          eyeLGroup.rotation.y = -0.3;
          this.head.add(eyeLGroup);
          const eyeL = new THREE.Mesh(eyeGeo, eyeColorMat);
          eyeLGroup.add(eyeL);

          const pupilGeo = new THREE.SphereGeometry(0.03, 8, 8);
          pupilGeo.scale(0.5, 1, 0.2);
          const pupilL = new THREE.Mesh(pupilGeo, pupilMat);
          pupilL.position.z = -0.05;
          eyeL.add(pupilL);

          const eyeRGroup = new THREE.Group();
          eyeRGroup.position.set(0.1, 0.02, -0.18);
          eyeRGroup.rotation.y = 0.3;
          this.head.add(eyeRGroup);
          const eyeR = new THREE.Mesh(eyeGeo, eyeColorMat);
          eyeRGroup.add(eyeR);
          const pupilR = new THREE.Mesh(pupilGeo, pupilMat);
          pupilR.position.z = -0.05;
          eyeR.add(pupilR);

          const earGeo = new THREE.ConeGeometry(0.08, 0.2, 4);
          const earL = new THREE.Mesh(earGeo, bodyMat);
          earL.position.set(-0.15, 0.2, -0.05);
          earL.rotation.z = 0.3;
          earL.rotation.y = -0.2;
          earL.rotation.x = -0.2;
          this.head.add(earL);

          const earR = new THREE.Mesh(earGeo, bodyMat);
          earR.position.set(0.15, 0.2, -0.05);
          earR.rotation.z = -0.3;
          earR.rotation.y = 0.2;
          earR.rotation.x = -0.2;
          this.head.add(earR);

          this.tail = [];
          let parent = this.abdomen;
          for (let i = 0; i < 5; i++) {
            const tGroup = new THREE.Group();
            if (i === 0) tGroup.position.set(0, 0.15, 0.35);
            else tGroup.position.set(0, 0, 0.18);

            const tSize = 0.08 - i * 0.01;
            const tGeo = new THREE.CylinderGeometry(tSize, tSize * 0.8, 0.2, 8);
            tGeo.rotateX(Math.PI / 2);
            const tMesh = new THREE.Mesh(tGeo, bodyMat);
            tMesh.position.z = 0.1;
            tGroup.add(tMesh);
            parent.add(tGroup);
            this.tail.push(tGroup);
            parent = tGroup;
          }

          this.legs = [];
          const legData = [
            { pos: [-0.22, -0.1, -0.3], parent: this.chest, isFront: true },
            { pos: [0.22, -0.1, -0.3], parent: this.chest, isFront: true },
            { pos: [-0.2, -0.1, 0.2], parent: this.abdomen, isFront: false },
            { pos: [0.2, -0.1, 0.2], parent: this.abdomen, isFront: false },
          ];

          legData.forEach((d) => {
            const lGroup = new THREE.Group();
            lGroup.position.set(d.pos[0], d.pos[1], d.pos[2]);
            d.parent.add(lGroup);

            const upperGeo = new THREE.CylinderGeometry(0.1, 0.07, 0.35, 8);
            const upper = new THREE.Mesh(upperGeo, bodyMat);
            upper.position.y = -0.15;
            lGroup.add(upper);

            const knee = new THREE.Group();
            knee.position.y = -0.3;
            upper.add(knee);

            const lowerGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.3, 8);
            const lower = new THREE.Mesh(lowerGeo, trimMat);
            lower.position.y = -0.15;
            if (!d.isFront) lower.rotation.x = 0.5;
            knee.add(lower);

            const pawGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.1, 8);
            pawGeo.rotateX(Math.PI / 2);
            const paw = new THREE.Mesh(pawGeo, data.socks ? socksMat : trimMat);
            paw.scale.set(1, 1, 1.5);
            paw.position.set(0, -0.15, 0.05);
            if (!d.isFront) paw.rotation.x = -0.5;
            lower.add(paw);

            this.legs.push({ root: lGroup, knee: knee, isFront: d.isFront });
          });

          scene.add(this.mesh);
        }

        update(dt) {
          if (this.invincible > 0) {
            this.invincible -= dt;
            this.mesh.visible = Math.floor(this.invincible * 20) % 2 === 0;
          } else {
            this.mesh.visible = true;
          }

          if (this.meowTimer > 0) {
            this.meowTimer -= dt;
            if (this.meowTimer <= 0) {
              if (Math.random() < 0.4) {
                AudioSys.meow();
              }
              this.meowTimer = Math.random() * 8 + 4;
            }
          }

          if (this.mesh.position.y > this.groundY || this.vy > 0) {
            this.vy -= 20 * dt;
            this.mesh.position.y += this.vy * dt;
            if (this.mesh.position.y <= this.groundY) {
              this.mesh.position.y = this.groundY;
              this.vy = 0;

              if (this.state === "jump") {
                this.toState("idle");
              } else if (this.state === "jump_attack") {
                this.toState("land_lag");
              } else if (this.state === "dive") {
                this.toState("land_lag");
              }
            }
          }

          if (this.mesh.position.y < this.groundY) {
            this.mesh.position.y = this.groundY;
            this.vy = 0;
            if (["jump", "dive", "jump_attack"].includes(this.state)) {
              if (this.state === "jump") this.toState("idle");
              else this.toState("land_lag");
            }
          }

          if (this.timer > 0) {
            this.timer -= dt;
            if (this.timer <= 0) {
              if (
                [
                  "attack",
                  "special",
                  "hit",
                  "dash",
                  "dive",
                  "jump_attack",
                  "ultimate",
                  "land_lag",
                  "guard",
                ].includes(this.state)
              ) {
                this.toState("idle");
              }
            }
          }

          if (this.state === "dash") {
            this.mesh.position.add(this.dashVec.clone().multiplyScalar(dt));
            if (Math.random() < 0.3)
              spawnParticles(this.mesh.position, 0xffffff);
          } else if (this.state === "dive") {
            const diveSpeed = 15.0;
            const dir = this.target.mesh.position
              .clone()
              .sub(this.mesh.position)
              .normalize();
            dir.y = -1.0;
            this.mesh.position.add(dir.multiplyScalar(diveSpeed * dt));
          }

          const t = clock.elapsedTime * 10;
          this.mesh.rotation.y =
            this.target && this.state !== "special" && this.state !== "ultimate"
              ? 0
              : this.mesh.rotation.y;

          this.hips.position.set(0, 0.55, 0);

          this.hips.rotation.z = 0;
          this.abdomen.rotation.x = 0;
          this.chest.rotation.x = 0;

          if (this.state === "run") {
            this.hips.position.y = 0.55 + Math.sin(t * 2) * 0.05;
            this.abdomen.rotation.x = Math.sin(t * 1.5) * 0.1;
            this.legs.forEach((l, i) => {
              const offset = i % 2 === 0 ? 0 : Math.PI;
              l.root.rotation.x = Math.sin(t + offset) * 0.8;
              l.knee.rotation.x = Math.abs(Math.sin(t + offset)) * 1.0;
            });
            this.tail.forEach(
              (seg, i) => (seg.rotation.y = Math.sin(t * 0.8 - i) * 0.3)
            );
          } else if (this.state === "idle") {
            this.hips.position.y = 0.55 + Math.sin(t * 0.5) * 0.02;
            this.legs.forEach((l) => {
              l.root.rotation.x = 0;
              l.knee.rotation.x = l.isFront ? 0 : 0.2;
            });
            this.tail.forEach(
              (seg, i) => (seg.rotation.y = Math.sin(t * 0.2 - i) * 0.1)
            );
          } else if (this.state === "attack") {
            const lungAmount = Math.sin(Math.PI * (1 - this.timer / 0.3)) * 0.2;
            this.hips.position.z += lungAmount;

            this.chest.rotation.x = -0.2;
            this.legs[1].root.rotation.x =
              -1.0 * Math.sin(Math.PI * (1 - this.timer / 0.3));
          } else if (this.state === "special") {
            this.mesh.rotation.y += 0.5;
            this.tail.forEach((seg) => (seg.rotation.x = 0.5));
          } else if (this.state === "dash") {
            this.hips.position.y = 0.4;
            this.legs.forEach((l) => (l.root.rotation.x = 1.0));
          } else if (this.state === "guard") {
            this.chest.rotation.x = 0.3;
            this.headGroup.rotation.x = 0.2;
          } else if (this.state === "jump" || this.state === "jump_attack") {
            this.legs.forEach((l) => {
              l.root.rotation.x = 0.5;
              l.knee.rotation.x = -1.0;
            });
          } else if (this.state === "dive") {
            this.modelGroup.rotation.x = 0.5;
            this.legs[1].root.rotation.x = -1.5;
          } else if (this.state === "land_lag") {
            this.hips.position.y = 0.4;
            this.legs.forEach((l) => {
              l.root.rotation.x = 0.5;
              l.knee.rotation.x = 0.8;
            });
          } else if (this.state === "ultimate") {
            this.mesh.rotation.y += 1.0;
            this.mesh.scale.setScalar(1.0 + Math.sin(t * 5) * 0.2);
          }

          if (this.state !== "ultimate") this.mesh.scale.setScalar(1);
          if (this.state !== "dive") this.modelGroup.rotation.x = 0;

          if (
            ["special", "ultimate", "jump_attack", "dive", "land_lag"].includes(
              this.state
            )
          ) {
          } else {
            if (this.target) {
              const targetPos = this.target.mesh.position.clone();
              targetPos.y = this.mesh.position.y;
              this.mesh.lookAt(targetPos);
            }
          }
          if (this.mesh.position.length() > 20)
            this.mesh.position.setLength(20);
        }

        toState(s) {
          this.state = s;
          if (s === "attack") {
            this.timer = 0.3;
            this.hasHit = false;
            AudioSys.swing();
          } else if (s === "special") {
            if (!this.data.infiniteBeams) {
              if (this.beamCount > 0) this.beamCount--;
            }
            this.timer = 0.8;
            this.hasHit = false;
            this.vy = 5;
            AudioSys.swing();
          } else if (s === "jump") {
            this.vy = 15;
            AudioSys.jump();
            this.hasHit = false;
          } else if (s === "hit") {
            this.timer = 0.4;
          } else if (s === "dash") {
            this.timer = 0.2;
            this.vy = 0;
            AudioSys.dash();
          } else if (s === "guard") {
            this.timer = this.isPlayer ? 0 : 0.5 + Math.random() * 0.5;
          } else if (s === "jump_attack") {
            this.timer = 0.4;
            this.hasHit = false;
            AudioSys.swing();
          } else if (s === "dive") {
            this.timer = 1.0;
            this.hasHit = false;
            this.vy = 0;
            AudioSys.swing();
          } else if (s === "land_lag") {
            this.timer = 0.5;
            this.hasHit = false;
          } else if (s === "ultimate") {
            this.timer = 1.5;
            this.hasHit = false;
            this.gauge = 0;
            AudioSys.ultimate();
            spawnParticles(this.mesh.position, 0xff00ff);
          }
        }

        takeDamage(amount) {
          if (this.invincible > 0) return;

          if (this.state === "guard") {
            amount *= 0.2;
            this.gauge += 5;

            if (this.gauge >= this.maxGauge) {
              this.gauge = this.maxGauge;
              if (this.isPlayer && this.beamCount < 3) {
                this.beamCount = 3;
              }
            }

            spawnParticles(this.mesh.position, 0x0088ff);
            this.hp -= amount;
            updateHUD();
            if (this.hp <= 0) {
              this.hp = 0;
              endRound(this.isPlayer);
            }
            return;
          }

          this.hp -= amount;
          this.gauge += 10;
          AudioSys.meow(true);

          if (this.gauge >= this.maxGauge) {
            this.gauge = this.maxGauge;
            if (this.isPlayer && this.beamCount < 3) {
              this.beamCount = 3;
            }
          }

          if (this.gauge > this.maxGauge) this.gauge = this.maxGauge;
          this.invincible = 1.0;
          this.toState("hit");
          const dir = this.mesh.position.clone().sub(this.target.mesh.position);
          dir.y = 0;
          dir.normalize();
          this.mesh.position.add(dir.multiplyScalar(2));
          this.mesh.position.y = Math.max(this.mesh.position.y, 0.5);
          spawnParticles(this.mesh.position, 0xff0000);
          AudioSys.hit();
          updateHUD();
          if (this.hp <= 0) {
            this.hp = 0;
            endRound(this.isPlayer);
          }
        }
      }

      // ③ スペシャル攻撃ビームのデザイン変更
      class Projectile {
        constructor(owner) {
          this.owner = owner;

          // Groupを使って複雑な形状を作成
          this.mesh = new THREE.Group();
          const color = 0x00ffff;
          const glowMat = new THREE.MeshBasicMaterial({ color: color });
          const clawMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

          // 肉球のパーム
          const palmGeo = new THREE.SphereGeometry(0.5, 12, 12);
          const palm = new THREE.Mesh(palmGeo, glowMat);
          palm.scale.set(1, 0.6, 1);
          this.mesh.add(palm);

          // 4つの指と爪
          for (let i = 0; i < 4; i++) {
            const angle = (i - 1.5) * 0.4; // 扇状に配置
            const fingerGroup = new THREE.Group();
            fingerGroup.position.set(
              Math.sin(angle) * 0.5,
              0,
              Math.cos(angle) * 0.5 - 0.2
            );
            fingerGroup.rotation.y = angle;

            // 指
            const finger = new THREE.Mesh(
              new THREE.SphereGeometry(0.2, 8, 8),
              glowMat
            );
            fingerGroup.add(finger);

            // 鋭い爪
            const clawGeo = new THREE.ConeGeometry(0.08, 0.5, 4);
            clawGeo.rotateX(-Math.PI / 2);
            const claw = new THREE.Mesh(clawGeo, clawMat);
            claw.position.z = 0.3;
            fingerGroup.add(claw);

            this.mesh.add(fingerGroup);
          }

          this.mesh.position.copy(owner.mesh.position);
          this.mesh.position.y = 1.0;
          this.mesh.lookAt(
            owner.target.mesh.position.x,
            1.0,
            owner.target.mesh.position.z
          );
          this.dir = new THREE.Vector3(0, 0, 1).applyQuaternion(
            this.mesh.quaternion
          );
          this.speed = 15;
          this.life = 2.0;
          scene.add(this.mesh);
        }
        update(dt) {
          this.life -= dt;
          this.mesh.position.add(
            this.dir.clone().multiplyScalar(this.speed * dt)
          );

          // 回転演出
          this.mesh.rotateZ(10 * dt);

          const targetPos = this.owner.target.mesh.position;
          const dx = this.mesh.position.x - targetPos.x;
          const dz = this.mesh.position.z - targetPos.z;
          const distXZ = Math.sqrt(dx * dx + dz * dz);
          const isJumpDodged = targetPos.y > 1.3;
          if (distXZ < 1.5 && !isJumpDodged) {
            this.owner.target.takeDamage(15);
            this.life = 0;
          }
          if (this.life <= 0) {
            scene.remove(this.mesh);
            return false;
          }
          return true;
        }
      }

      function spawnParticles(pos, color) {
        const mat = new THREE.MeshBasicMaterial({ color: color });
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        for (let i = 0; i < 8; i++) {
          const mesh = new THREE.Mesh(geo, mat);
          mesh.position.copy(pos);
          mesh.position.y += 0.5;
          scene.add(mesh);
          particles.push({
            mesh: mesh,
            vel: new THREE.Vector3(
              Math.random() - 0.5,
              Math.random(),
              Math.random() - 0.5
            ).multiplyScalar(0.2),
            life: 1.0,
          });
        }
      }

      let inputLock = {
        attack: false,
        special: false,
        ultimate: false,
        jump: false,
        dash: false,
        guard: false,
      };

      function resolveCollision(c1, c2) {
        const p1 = c1.mesh.position;
        const p2 = c2.mesh.position;

        const dx = p1.x - p2.x;
        const dz = p1.z - p2.z;
        const distSq = dx * dx + dz * dz;
        const minDist = 1.5;

        const dy = Math.abs(p1.y - p2.y);

        if (distSq < minDist * minDist && dy < 2.0) {
          const dist = Math.sqrt(distSq);
          const overlap = minDist - dist;
          const nx = dist > 0.01 ? dx / dist : 1;
          const nz = dist > 0.01 ? dz / dist : 0;

          const pushX = nx * overlap * 0.5;
          const pushZ = nz * overlap * 0.5;

          c1.mesh.position.x += pushX;
          c1.mesh.position.z += pushZ;
          c2.mesh.position.x -= pushX;
          c2.mesh.position.z -= pushZ;
        }
      }

      function updateGame(dt) {
        Input.update();
        if (!Input.attack) inputLock.attack = false;
        if (!Input.special) inputLock.special = false;
        if (!Input.ultimate) inputLock.ultimate = false;
        if (!Input.jump) inputLock.jump = false;
        if (!Input.dash) inputLock.dash = false;

        if (player.state === "guard" && !Input.guard) {
          player.state = "idle";
        }
        const canAct =
          player.state === "idle" ||
          player.state === "run" ||
          player.state === "guard";

        if (
          player.state === "idle" ||
          player.state === "run" ||
          player.state === "jump"
        ) {
          const speed = 6.0 * player.data.speed;
          let moving = false;
          const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(
            camera.quaternion
          );
          fwd.y = 0;
          fwd.normalize();
          const right = new THREE.Vector3(1, 0, 0).applyQuaternion(
            camera.quaternion
          );
          right.y = 0;
          right.normalize();

          if (Math.abs(Input.y) > 0.1 || Math.abs(Input.x) > 0.1) {
            const moveDir = fwd
              .clone()
              .multiplyScalar(-Input.y)
              .add(right.clone().multiplyScalar(Input.x));

            if (
              Input.dash &&
              !inputLock.dash &&
              player.gauge >= 10 &&
              player.state !== "dash" &&
              player.state !== "jump"
            ) {
              inputLock.dash = true;
              player.toState("dash");
              player.gauge -= 10;
              let dDir = moveDir.clone();
              if (dDir.lengthSq() === 0) {
                dDir = new THREE.Vector3(0, 0, 1).applyQuaternion(
                  player.mesh.quaternion
                );
              }
              dDir.normalize().multiplyScalar(speed * 8);
              player.dashVec.copy(dDir);
            } else {
              player.mesh.position.add(moveDir.multiplyScalar(speed * dt));
              moving = true;
            }
          }
          if (player.state === "idle" && moving) player.state = "run";
          if (player.state === "run" && !moving) player.state = "idle";
        }

        if (
          Input.ultimate &&
          !inputLock.ultimate &&
          player.gauge >= 100 &&
          canAct
        ) {
          inputLock.ultimate = true;
          player.toState("ultimate");
        } else if (
          Input.special &&
          !inputLock.special &&
          canAct &&
          player.beamCount > 0
        ) {
          inputLock.special = true;
          player.toState("special");
          projectiles.push(new Projectile(player));
          AudioSys.beam();
        } else if (Input.attack && !inputLock.attack) {
          if (player.state === "jump") {
            if (!player.hasHit) {
              inputLock.attack = true;
              player.toState("dive");
            }
          } else if (canAct) {
            inputLock.attack = true;
            player.toState("attack");
          }
        } else if (Input.guard && canAct) {
          if (player.state !== "guard") player.toState("guard");
        } else if (
          Input.jump &&
          !inputLock.jump &&
          canAct &&
          player.mesh.position.y <= 0.1
        ) {
          inputLock.jump = true;
          player.toState("jump");
        }

        if (enemy.state === "idle" || enemy.state === "run") {
          if (enemy.comboReady && enemy.state === "idle") {
            if (enemy.beamCount > 0 || enemy.data.infiniteBeams) {
              enemy.toState("special");
              projectiles.push(new Projectile(enemy));
              AudioSys.beam();
              enemy.comboReady = false;
              return;
            }
            enemy.comboReady = false;
          }
          const dist = enemy.mesh.position.distanceTo(player.mesh.position);
          const aiLevel = enemy.data.aiLevel || 1;
          const isBossTier = aiLevel >= 9;

          if (enemy.forceApproach) {
            if (dist < 2.0) {
              enemy.forceApproach = false;
              enemy.consecutiveShots = 0;
            } else {
              const dir = player.mesh.position
                .clone()
                .sub(enemy.mesh.position)
                .normalize();
              enemy.mesh.position.add(
                dir.multiplyScalar(enemy.data.speed * 4 * dt)
              );
              enemy.state = "run";
            }
          }

          let reactingToJump = false;
          if (
            (player.state === "jump" ||
              player.state === "jump_attack" ||
              player.state === "dive") &&
            aiLevel >= 3
          ) {
            const jumpReactionChance = 0.1 + aiLevel * 0.05;
            if (Math.random() < jumpReactionChance && dist < 5.0) {
              reactingToJump = true;
              if (enemy.gauge >= 10 && Math.random() < 0.5) {
                const backDir = enemy.mesh.position
                  .clone()
                  .sub(player.mesh.position)
                  .normalize();
                enemy.dashVec.copy(
                  backDir.multiplyScalar(enemy.data.speed * 8)
                );
                enemy.toState("dash");
                enemy.gauge -= 10;
              } else {
                enemy.toState("guard");
              }
            }
          }

          if (!enemy.forceApproach && !reactingToJump) {
            let dir = player.mesh.position
              .clone()
              .sub(enemy.mesh.position)
              .normalize();
            if (aiLevel >= 2) {
              const side = new THREE.Vector3(dir.z, 0, -dir.x);
              const sway =
                Math.sin(clock.getElapsedTime() * 2.0 + aiLevel) * 0.8;
              dir.add(side.multiplyScalar(sway * 0.5)).normalize();
            }
            let defensiveAction = false;

            if (
              aiLevel >= 4 &&
              (player.state === "attack" ||
                player.state === "special" ||
                player.state === "dive" ||
                player.state === "dash")
            ) {
              if (player.state === "attack" && dist < 2.5) {
                const blockChance = 0.3 + (aiLevel - 4) * 0.1;
                if (Math.random() < blockChance) {
                  enemy.toState("guard");
                  defensiveAction = true;
                }
              }

              if (!defensiveAction && dist < 4.5) {
                const reactProb = 0.2 + aiLevel * 0.1;
                if (Math.random() < reactProb) {
                  if (aiLevel >= 6 && Math.random() < 0.6 && enemy.gauge > 10) {
                    const dodgeDir = new THREE.Vector3(
                      dir.z,
                      0,
                      -dir.x
                    ).multiplyScalar(Math.random() < 0.5 ? 1 : -1);
                    if (Math.random() < 0.3) dodgeDir.copy(dir).negate();
                    enemy.dashVec.copy(
                      dodgeDir.normalize().multiplyScalar(enemy.data.speed * 48)
                    );
                    enemy.toState("dash");
                    enemy.gauge -= 10;
                    if (
                      aiLevel >= 7 &&
                      (enemy.beamCount > 0 || enemy.data.infiniteBeams) &&
                      Math.random() < 0.7
                    ) {
                      enemy.comboReady = true;
                    }
                    defensiveAction = true;
                  } else {
                    const side = new THREE.Vector3(
                      dir.z,
                      0,
                      -dir.x
                    ).multiplyScalar(Math.random() < 0.5 ? 1 : -1);
                    dir.negate().add(side.multiplyScalar(0.8)).normalize();
                    enemy.mesh.position.add(
                      dir.multiplyScalar(enemy.data.speed * 6 * dt)
                    );
                    defensiveAction = true;
                  }
                }
              }
            }

            if (!defensiveAction) {
              let aggression = 0.01 + aiLevel * 0.005;
              if (isBossTier) aggression *= 1.5;
              if (aiLevel >= 7 && dist < 1.5 && Math.random() < 0.05) {
                dir.negate();
              }

              if (
                aiLevel >= 5 &&
                (enemy.beamCount > 0 || enemy.data.infiniteBeams) &&
                dist < 6.0 &&
                dist > 2.5
              ) {
                if (Math.random() < 0.02) {
                  dir.negate();
                }
              }

              if (Math.random() < aggression) {
                const beamRangeTrigger = isBossTier ? 4.0 : 3.0;
                if (
                  (dist > beamRangeTrigger || (aiLevel >= 5 && dist > 3.0)) &&
                  !enemy.forceApproach
                ) {
                  let shootProb = 0.3;
                  if (aiLevel >= 5 && enemy.beamCount > 0) shootProb = 0.6;

                  if (enemy.consecutiveShots < 3 && Math.random() < shootProb) {
                    enemy.toState("special");
                    projectiles.push(new Projectile(enemy));
                    AudioSys.beam();
                    enemy.consecutiveShots++;
                    if (enemy.consecutiveShots >= 3) enemy.forceApproach = true;
                    return;
                  }
                }
                if (dist > 2.2) {
                  if (
                    isBossTier &&
                    !enemy.forceApproach &&
                    enemy.consecutiveShots < 3 &&
                    Math.random() < 0.3
                  ) {
                    enemy.toState("special");
                    projectiles.push(new Projectile(enemy));
                    AudioSys.beam();
                    enemy.consecutiveShots++;
                    if (enemy.consecutiveShots >= 3) enemy.forceApproach = true;
                  } else {
                    enemy.mesh.position.add(
                      dir.multiplyScalar(enemy.data.speed * 4 * dt)
                    );
                    enemy.state = "run";
                  }
                } else {
                  const roll = Math.random();
                  if (roll < 0.6) enemy.toState("attack");
                  else if (
                    roll < 0.75 &&
                    (enemy.beamCount > 0 || enemy.data.infiniteBeams) &&
                    aiLevel > 2
                  ) {
                    enemy.toState("special");
                    projectiles.push(new Projectile(enemy));
                    AudioSys.beam();
                  } else if (roll < 0.85 && enemy.gauge >= 100 && aiLevel > 5)
                    enemy.toState("ultimate");
                  else enemy.toState("jump");
                }
              } else {
                if (dist > 2.0 || (aiLevel >= 2 && dist > 1.5)) {
                  enemy.mesh.position.add(
                    dir.multiplyScalar(enemy.data.speed * 4 * dt)
                  );
                  enemy.state = "run";
                } else {
                  enemy.state = "idle";
                }
              }
            }
          }
        }

        player.update(dt);
        enemy.update(dt);
        resolveCollision(player, enemy);
        checkHit(player, enemy);
        checkHit(enemy, player);

        for (let i = projectiles.length - 1; i >= 0; i--) {
          if (!projectiles[i].update(dt)) projectiles.splice(i, 1);
        }
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.life -= dt * 2;
          p.mesh.position.add(p.vel);
          p.mesh.rotation.x += dt;
          if (p.life <= 0) {
            scene.remove(p.mesh);
            particles.splice(i, 1);
          }
        }

        const mid = player.mesh.position
          .clone()
          .add(enemy.mesh.position)
          .multiplyScalar(0.5);
        const dist = player.mesh.position.distanceTo(enemy.mesh.position);
        const camTargetPos = new THREE.Vector3(
          mid.x,
          5 + dist * 0.3,
          mid.z + 8 + dist * 0.5
        );
        camera.position.lerp(camTargetPos, 0.05);
        camera.lookAt(mid);
        updateHUD();
      }

      function checkHit(atk, def) {
        if (
          (atk.state === "attack" ||
            atk.state === "jump_attack" ||
            atk.state === "ultimate" ||
            atk.state === "dive") &&
          !atk.hasHit
        ) {
          const dist = atk.mesh.position.distanceTo(def.mesh.position);
          if (dist < 2.0) {
            atk.hasHit = true;
            let dmg = 8;
            if (atk.state === "jump_attack") dmg = 12;
            if (atk.state === "ultimate") dmg = 40;
            if (atk.state === "dive") dmg = 15;
            dmg *= atk.data.power;
            def.takeDamage(dmg);
          }
        }
      }

      function startGame() {
        AudioSys.init();
        document.getElementById("title-screen").classList.add("hidden");
        document.getElementById("select-screen").classList.remove("hidden");
        const grid = document.getElementById("char-grid");
        grid.innerHTML = "";
        PLAYER_CATS.forEach((cat, i) => {
          const d = document.createElement("div");
          d.className = "char-card";
          const spdPct = Math.min(100, cat.speed * 50);
          const pwrPct = Math.min(100, cat.power * 50);
          d.innerHTML = `
                    <div class="char-preview-box" style="background:#${new THREE.Color(
                      cat.color
                    ).getHexString()}; border-color:#${new THREE.Color(
            cat.trim
          ).getHexString()};">
                        <div style="width:100%; height:100%; border-radius:50%; box-shadow: inset 0 0 20px rgba(0,0,0,0.8);"></div>
                        <div style="position:absolute; top:35%; left:20%; width:15px; height:10px; background:#${new THREE.Color(
                          cat.eye
                        ).getHexString()}; border-radius:50%; box-shadow:0 0 5px #${new THREE.Color(
            cat.eye
          ).getHexString()};"></div>
                        <div style="position:absolute; top:35%; right:20%; width:15px; height:10px; background:#${new THREE.Color(
                          cat.eye
                        ).getHexString()}; border-radius:50%; box-shadow:0 0 5px #${new THREE.Color(
            cat.eye
          ).getHexString()};"></div>
                    </div>
                    <div class="char-name" style="color:#${new THREE.Color(
                      cat.trim
                    ).getHexString()}; text-shadow:0 0 5px #${new THREE.Color(
            cat.trim
          ).getHexString()}">${cat.name}</div>
                    <div class="stat-row"><span class="stat-label">SPD</span><div class="stat-bar-bg"><div class="stat-bar-fill spd-fill" style="width:${spdPct}%"></div></div></div>
                    <div class="stat-row"><span class="stat-label">PWR</span><div class="stat-bar-bg"><div class="stat-bar-fill pwr-fill" style="width:${pwrPct}%"></div></div></div>
                `;
          d.onclick = () => {
            document
              .querySelectorAll(".char-card")
              .forEach((c) => c.classList.remove("active"));
            d.classList.add("active");
            setTimeout(() => {
              playerIdx = i;
              currentLevel = 0;
              retryCredits = 3;
              document.getElementById("select-screen").classList.add("hidden");
              startMatch();
            }, 500);
          };
          grid.appendChild(d);
        });
      }

      function startMatch() {
        if (player) {
          scene.remove(player.mesh);
          scene.remove(enemy.mesh);
        }
        projectiles.forEach((p) => scene.remove(p.mesh));
        projectiles = [];
        particles.forEach((p) => scene.remove(p.mesh));
        particles = [];
        Input.reset();
        inputLock.attack = false;
        inputLock.special = false;
        inputLock.ultimate = false;
        inputLock.jump = false;
        inputLock.dash = false;

        player = new Cat(PLAYER_CATS[playerIdx], true, 5);
        const enemyData =
          ENEMY_CATS[Math.min(currentLevel, ENEMY_CATS.length - 1)];

        enemy = new Cat(enemyData, false, -5);
        if (!enemy.data.infiniteBeams) {
          const currentEnemyLvl = enemy.data.aiLevel || 1;
          if (currentEnemyLvl >= 6) {
            enemy.beamCount = 3 + (currentEnemyLvl - 5) * 2;
          }
        }

        player.target = enemy;
        enemy.target = player;
        document.getElementById("hud").style.display = "flex";
        document.getElementById("controls-area").style.display = "flex";
        document.getElementById("result-screen").classList.add("hidden");
        document.getElementById("level-display").innerText =
          "Lv." + (currentLevel + 1);

        // ステージごとの床とBGM更新
        updateStageFloor(currentLevel);
        AudioSys.playBGM(currentLevel);

        updateHUD();
        currentState = GAME_STATE.FIGHT;
      }

      function updateHUD() {
        // ★ テストやタイトル画面など、player / enemy が未初期化のときは何もしない
        if (!player || !enemy) {
          return;
        }
        const p1pct = (player.hp / player.maxHp) * 100;
        const p2pct = (enemy.hp / enemy.maxHp) * 100;
        document.getElementById("p1-hp").style.width = Math.max(0, p1pct) + "%";
        document.getElementById("p2-hp").style.width = Math.max(0, p2pct) + "%";
        document.getElementById("p1-gauge").style.width =
          Math.min(100, player.gauge) + "%";
        document.getElementById("p2-gauge").style.width =
          Math.min(100, enemy.gauge) + "%";
        document.getElementById("enemy-name").innerText = enemy.data.name;
        const spBtn = document.getElementById("btn-sp");
        spBtn.innerHTML = `SP<br>(X)<br><span style="font-size:10px; color:${
          player.beamCount > 0 ? "#ffff00" : "#888"
        }">Rem:${player.beamCount}</span>`;
        if (player.beamCount <= 0) {
          spBtn.classList.add("disabled");
        } else {
          spBtn.classList.remove("disabled");
        }
      }

      function endRound(playerLost) {
        currentState = GAME_STATE.END;
        AudioSys.stopBGM(); // 勝敗がついたらBGM停止
        setTimeout(() => {
          document.getElementById("hud").style.display = "none";
          document.getElementById("controls-area").style.display = "none";
          const scr = document.getElementById("result-screen");
          scr.classList.remove("hidden");
          if (playerLost) {
            retryCredits--;
            if (retryCredits > 0) {
              document.getElementById("result-msg").innerText = "DEFEATED";
              document.getElementById("result-msg").style.color = "#ff0055";
              document.getElementById(
                "retry-btn"
              ).innerText = `RETRY (残り${retryCredits}回)`;
              document.getElementById("retry-btn").onclick = startMatch;
            } else {
              document.getElementById("result-msg").innerText = "GAME OVER";
              document.getElementById("result-msg").style.color = "#555";
              document.getElementById("retry-btn").innerText = "TITLE";
              document.getElementById("retry-btn").onclick = () => {
                location.reload();
              };
            }
          } else {
            currentLevel++;
            if (currentLevel >= ENEMY_CATS.length) {
              document.getElementById("result-msg").innerText = "ALL CLEAR!!";
              document.getElementById("result-msg").style.color = "#00ffff";
              document.getElementById("retry-btn").innerText = "TITLE";
              document.getElementById("retry-btn").onclick = () => {
                location.reload();
              };
            } else {
              document.getElementById("result-msg").innerText = "WIN!!";
              document.getElementById("result-msg").style.color = "#00ffff";
              document.getElementById("retry-btn").innerText = "NEXT STAGE";
              document.getElementById("retry-btn").onclick = startMatch;
            }
          }
        }, 1500);
      }

      function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        if (currentState === GAME_STATE.FIGHT) updateGame(dt);
        renderer.render(scene, camera);
      }
      window.onload = function () {
        init3D();
        Input.init();
        document.getElementById("start-btn").onclick = startGame;
        document.getElementById("retry-btn").onclick = startMatch;
        animate();
      };

      /* =========================
           ここからテスト用フレームワーク
           ========================= */

      // シンプルなアサート関数
      function nyannyanAssert(condition, message) {
        if (!condition) {
          throw new Error(message || "Assertion failed");
        }
      }

      function nyannyanAssertEqual(actual, expected, message) {
        if (actual !== expected) {
          throw new Error(
            (message ? message + " : " : "") +
              `expected ${expected}, but got ${actual}`
          );
        }
      }

      // テストランナー
      const NekkenTestRunner = {
        tests: [],

        // 直近の実行結果を保持して、画面側で参照できるようにする
        lastResult: null,

        /**
         * テストを登録する
         * @param {string} name - テスト名
         * @param {Function} fn - 実行する関数（失敗時は throw する）
         */
        add(name, fn) {
          this.tests.push({ name, fn });
        },

        /**
         * すべてのテストを実行し、結果を lastResult に保存する
         * @returns {boolean} - すべて成功したら true
         */
        runAll() {
          console.group(
            "%c[TEST] NEKKEN self-check",
            "color:cyan;font-weight:bold;"
          );

          let failed = 0;
          const results = [];

          this.tests.forEach((t, idx) => {
            try {
              // テスト本体を実行
              t.fn();

              // 成功した結果を保存
              results.push({
                name: t.name,
                ok: true,
                error: null,
              });

              console.log(`%c✓ (${idx + 1}) ${t.name}`, "color:lightgreen;");
            } catch (e) {
              failed++;

              // 失敗した結果を保存
              results.push({
                name: t.name,
                ok: false,
                error: e, // message / stack を後から参照する
              });

              console.groupCollapsed(
                `%c✗ (${idx + 1}) ${t.name}`,
                "color:red;font-weight:bold;"
              );
              console.error("Message:", e.message);
              if (e.stack) {
                console.error("Stack:\n", e.stack);
              } else {
                console.error("Error object:", e);
              }
              console.groupEnd();
            }
          });

          if (failed > 0) {
            console.error(
              `%c${failed} test(s) failed. ゲーム起動を中止しました。`,
              "color:red;font-weight:bold;"
            );
          } else {
            console.log(
              "%cAll tests passed. ゲームを開始できます。",
              "color:lime;font-weight:bold;"
            );
          }
          console.groupEnd();

          // 画面表示用に結果を覚えておく
          this.lastResult = {
            total: this.tests.length,
            failed: failed,
            results: results,
          };

          return failed === 0;
        },
      };

      /**
       * SELF TEST 画面に結果を反映する
       * @param {object} result - TestRunner.lastResult 相当
       * @param {boolean} allPassed - すべて成功したかどうか
       */
      function renderTestResult(result, allPassed) {
        const summaryEl = document.getElementById("test-summary");
        const detailEl = document.getElementById("test-detail");
        const continueBtn = document.getElementById("test-continue-btn");
        const forceBtn = document.getElementById("test-force-btn"); // ★追加

        if (!summaryEl || !detailEl || !continueBtn) return;

        if (allPassed) {
          summaryEl.innerHTML = `
            <span class="test-summary-ok">
                All ${result.total} tests passed. 🎉
            </span><br>
            ゲームを開始できます。
        `;
          continueBtn.classList.remove("hidden");

          // ★全部パスしたときは FORCE ボタンは隠しておく（あってもいいけど分かりやすさ優先）
          if (forceBtn) {
            forceBtn.classList.add("hidden");
          }
        } else {
          summaryEl.innerHTML = `
            <span class="test-summary-fail">
                ${result.failed} / ${result.total} tests failed.
            </span><br>
            ゲーム起動は無効化されています。<br>
            下の一覧から失敗しているテストを確認してください。
        `;
          continueBtn.classList.add("hidden");

          // ★失敗しているときだけ「FORCE START (DEV)」を出す
          if (forceBtn) {
            forceBtn.classList.remove("hidden");
          }
        }

        // 以下、詳細リスト部分はそのまま
        detailEl.innerHTML = "";

        result.results.forEach((r, idx) => {
          const container = document.createElement("div");
          container.className = r.ok ? "test-item-ok" : "test-item-fail";

          const nameLine = document.createElement("div");
          nameLine.className = "test-item-name";
          nameLine.textContent = `${r.ok ? "✓" : "✗"} (${idx + 1}) ${r.name}`;
          container.appendChild(nameLine);

          if (!r.ok && r.error) {
            const msgLine = document.createElement("div");
            msgLine.className = "test-item-message";
            msgLine.textContent = r.error.message || String(r.error);
            container.appendChild(msgLine);
          }

          detailEl.appendChild(container);
        });
      }

      /* =========================
           テストケース定義
           ========================= */

      // 1. データ定義の基本チェック
      NekkenTestRunner.add(
        "PLAYER_CATS / ENEMY_CATS が配列で定義されている",
        () => {
          nyannyanAssert(
            Array.isArray(PLAYER_CATS),
            "PLAYER_CATS は配列である必要があります"
          );
          nyannyanAssert(
            Array.isArray(ENEMY_CATS),
            "ENEMY_CATS は配列である必要があります"
          );
          nyannyanAssert(
            PLAYER_CATS.length > 0,
            "プレイヤー用の猫が1体以上必要です"
          );
          nyannyanAssert(ENEMY_CATS.length > 0, "敵用の猫が1体以上必要です");
        }
      );

      // 2. 各キャラの必須プロパティの型チェック
      NekkenTestRunner.add(
        "キャラ定義の必須プロパティ（name/speed/power/hpMulti）",
        () => {
          const checkCat = (cat, idx, isEnemy) => {
            const prefix = (isEnemy ? "ENEMY" : "PLAYER") + `[${idx}]`;
            nyannyanAssert(
              typeof cat.name === "string",
              `${prefix}.name は文字列`
            );
            nyannyanAssert(
              typeof cat.speed === "number",
              `${prefix}.speed は数値`
            );
            nyannyanAssert(
              typeof cat.power === "number",
              `${prefix}.power は数値`
            );
            nyannyanAssert(
              typeof cat.hpMulti === "number",
              `${prefix}.hpMulti は数値`
            );
          };
          PLAYER_CATS.forEach((c, i) => checkCat(c, i, false));
          ENEMY_CATS.forEach((c, i) => checkCat(c, i, true));
        }
      );

      // 3. Cat コンストラクタの基本挙動
      NekkenTestRunner.add(
        "Cat コンストラクタで HP / gauge が正しく初期化される",
        () => {
          // テスト用に1体だけ生成
          const tempCat = new Cat(PLAYER_CATS[0], true, 0);

          try {
            // --- ここから先はテスト本体 ---
            nyannyanAssert(tempCat.maxHp > 0, "maxHp は正の値であるべきです");
            nyannyanAssertEqual(
              tempCat.hp,
              tempCat.maxHp,
              "hp は maxHp と同じであるべきです"
            );
            nyannyanAssertEqual(tempCat.gauge, 0, "gauge の初期値は 0 のはず");
            nyannyanAssertEqual(
              tempCat.beamCount,
              3,
              "プレイヤーの初期ビーム弾数は 3 の想定"
            );
          } finally {
            // --- テストが成功しても失敗しても必ず呼ばれる ---
            if (scene && tempCat && tempCat.mesh) {
              scene.remove(tempCat.mesh);
            }
          }
        }
      );

      // 4. ビーム弾数ロジックテスト
      NekkenTestRunner.add(
        "ゲージMAX時にプレイヤーのビーム弾数が補充される",
        () => {
          const tempCat = new Cat(PLAYER_CATS[0], true, 0);

          try {
            tempCat.target = tempCat; // ダミー
            tempCat.beamCount = 0;
            tempCat.gauge = tempCat.maxGauge - 10;

            // ちょっとダメージを与える → gauge +=10 → maxGauge に到達
            tempCat.takeDamage(1);

            nyannyanAssertEqual(
              tempCat.gauge,
              tempCat.maxGauge,
              "ダメージでゲージが max まで増える想定"
            );
            nyannyanAssert(
              tempCat.beamCount >= 1,
              "ゲージMAX到達時にビーム弾数が（0から）増えているはず"
            );
          } finally {
            if (scene && tempCat && tempCat.mesh) {
              scene.remove(tempCat.mesh);
            }
          }
        }
      );

      /* =========================
           ブートストラップ処理
           ========================= */
      window.onload = function () {
        // まず 3D と入力を初期化
        init3D();
        Input.init();

        const titleScreen = document.getElementById("title-screen");
        const selectScreen = document.getElementById("select-screen");
        const resultScreen = document.getElementById("result-screen");
        const testScreen = document.getElementById("test-screen");

        if (titleScreen) titleScreen.classList.add("hidden");
        if (selectScreen) selectScreen.classList.add("hidden");
        if (resultScreen) resultScreen.classList.add("hidden");
        if (testScreen) testScreen.classList.remove("hidden");

        // ★ 共通の「ゲーム起動準備」関数
        function enterGameFromTestScreen() {
          // SELF TEST 画面を閉じてタイトルへ
          if (testScreen) testScreen.classList.add("hidden");
          if (titleScreen) titleScreen.classList.remove("hidden");

          // 従来通りのイベント設定
          document.getElementById("start-btn").onclick = startGame;
          document.getElementById("retry-btn").onclick = startMatch;

          // ゲームループ開始
          animate();
        }

        // ★ テスト実行
        const allPassed = NekkenTestRunner.runAll();
        const result = NekkenTestRunner.lastResult;

        if (result) {
          renderTestResult(result, allPassed);
        }

        // テスト成功時のみ: CONTINUE でゲーム起動
        const continueBtn = document.getElementById("test-continue-btn");
        if (continueBtn) {
          continueBtn.onclick = function () {
            enterGameFromTestScreen();
          };
        }

        // ★テスト失敗時でも: FORCE START (DEV) から起動可能に
        const forceBtn = document.getElementById("test-force-btn");
        if (forceBtn) {
          forceBtn.onclick = function () {
            console.warn(
              "[TEST] 強制起動: テストが失敗していますが、開発者モードでゲームを開始します。"
            );
            enterGameFromTestScreen();
          };
        }

        // 失敗している場合は、ユーザー操作があるまでゲームは動かさない。
        // （CONTINUE or FORCE を押したときだけ animate() が走る）
      };
    </script>
  </body>
</html>
