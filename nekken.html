<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEKKEN: ARCADE MODE</title>
    <style>
        /* スタイル設定 (変更なし) */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', sans-serif;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
        }

        .health-bar-wrapper {
            width: 40%;
            position: relative;
        }

        .health-bar-bg {
            width: 100%;
            height: 20px;
            background: #222;
            border: 2px solid #444;
            transform: skewX(-20deg);
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

        .hp-p1 {
            background: linear-gradient(90deg, #ff9900, #ffff00);
            float: right;
        }

        .hp-p2 {
            background: linear-gradient(90deg, #ff0055, #ff55aa);
            transform-origin: left;
        }

        .gauge-bar-wrapper {
            width: 100%;
            height: 8px;
            background: #111;
            border: 1px solid #333;
            margin-top: 2px;
            transform: skewX(-20deg);
        }

        .gauge-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            box-shadow: 0 0 5px #00ffff;
            transition: width 0.1s linear;
        }

        .name-label {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            margin-top: 5px;
            text-shadow: 0 0 5px #00ffff;
            letter-spacing: 1px;
        }

        .round-badge {
            color: #00ffff;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 0 0 10px #00ffff;
            text-align: center;
        }

        #controls-area {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 180px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .control-zone {
            pointer-events: auto;
            position: relative;
        }

        #joystick-zone {
            width: 150px;
            height: 150px;
        }

        #stick-base {
            width: 120px;
            height: 120px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            position: absolute;
            bottom: 10px;
            left: 10px;
        }

        #stick-knob {
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #00ffff;
        }

        #action-zone {
            width: 180px;
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 5px;
        }

        .btn-action {
            border-radius: 50%;
            background: rgba(255, 0, 85, 0.2);
            border: 2px solid rgba(255, 0, 85, 0.5);
            color: #fff;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: transform 0.1s, background 0.1s;
            text-align: center;
            line-height: 1.1;
        }

        .btn-action:active,
        .btn-action.pressed {
            background: rgba(255, 0, 85, 0.6);
            transform: scale(0.95);
        }

        .btn-action.disabled {
            background: rgba(50, 50, 50, 0.5) !important;
            border-color: #555 !important;
            color: #888 !important;
            pointer-events: none;
            filter: grayscale(100%);
            opacity: 0.6;
        }

        #btn-atk {
            grid-column: 3;
            grid-row: 2;
            width: 65px;
            height: 65px;
            align-self: end;
            justify-self: end;
        }

        #btn-jump {
            grid-column: 2;
            grid-row: 2;
            width: 50px;
            height: 50px;
            align-self: end;
            margin-bottom: 10px;
        }

        #btn-sp {
            grid-column: 3;
            grid-row: 1;
            width: 45px;
            height: 45px;
            align-self: end;
            border-color: #ffff00;
            color: #ffff00;
            background: rgba(255, 255, 0, 0.2);
        }

        #btn-ult {
            grid-column: 2;
            grid-row: 1;
            width: 45px;
            height: 45px;
            align-self: end;
            border-color: #ff00ff;
            color: #ff00ff;
            background: rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 5px #ff00ff;
        }

        #btn-dash {
            grid-column: 1;
            grid-row: 2;
            width: 50px;
            height: 50px;
            align-self: end;
            border-color: #00ff00;
            color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
        }

        #btn-guard {
            grid-column: 1;
            grid-row: 1;
            width: 45px;
            height: 45px;
            align-self: end;
            border-color: #0088ff;
            color: #0088ff;
            background: rgba(0, 136, 255, 0.2);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
            transition: opacity 0.5s;
        }

        h1 {
            color: #fff;
            font-size: 40px;
            letter-spacing: 5px;
            border-bottom: 2px solid #00ffff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ffff;
            text-align: center;
        }

        .btn-cyber {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            letter-spacing: 2px;
            margin: 10px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            transition: all 0.2s;
        }

        .btn-cyber:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px #00ffff;
        }

        .btn-cyber:active {
            background: #00ffff;
            color: #000;
        }

        #select-screen {
            background: linear-gradient(135deg, #050510 0%, #1a1a2e 100%);
            overflow-y: auto;
        }

        #select-screen h2 {
            font-size: 32px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            letter-spacing: 4px;
            margin-bottom: 20px;
            text-transform: uppercase;
            border-bottom: 2px solid #00ffff;
            padding-bottom: 10px;
            margin-top: 40px;
        }

        .char-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 25px;
            max-width: 900px;
            width: 100%;
            padding: 20px;
            padding-bottom: 50px;
            scrollbar-width: thin;
            scrollbar-color: #00ffff #111;
        }

        .char-card {
            background: rgba(20, 20, 30, 0.8);
            border: 1px solid #444;
            border-left: 4px solid #444;
            border-radius: 4px;
            padding: 15px;
            text-align: center;
            color: #fff;
            cursor: pointer;
            width: 160px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        .char-card:hover {
            transform: translateY(-5px) scale(1.05);
            border-color: #00ffff;
            border-left-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            background: rgba(0, 40, 40, 0.8);
        }

        .char-card.active {
            border-color: #ff0055;
            border-left-color: #ff0055;
            background: rgba(40, 0, 20, 0.9);
            box-shadow: 0 0 30px rgba(255, 0, 85, 0.6);
            transform: scale(1.1);
            z-index: 10;
        }

        .char-preview-box {
            width: 80px;
            height: 80px;
            margin: 0 auto 15px;
            border-radius: 50%;
            border: 3px solid #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            position: relative;
            background-color: #000;
            transition: 0.3s;
        }

        .char-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .stat-row {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 10px;
            color: #aaa;
            font-family: monospace;
        }

        .stat-label {
            width: 25px;
            text-align: left;
            font-weight: bold;
        }

        .stat-bar-bg {
            flex-grow: 1;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            width: 0%;
            transition: width 0.5s ease-out;
        }

        .pwr-fill {
            background: linear-gradient(90deg, #ff5500, #ffaa00);
        }

        .spd-fill {
            background: linear-gradient(90deg, #0088ff, #00ffff);
        }

        @media (max-width: 600px) {
            .char-grid {
                padding: 10px;
                gap: 15px;
                padding-bottom: 80px;
            }

            .char-card {
                width: 42%;
                padding: 10px;
            }

            .char-preview-box {
                width: 60px;
                height: 60px;
                margin-bottom: 10px;
            }

            .char-name {
                font-size: 12px;
                margin-bottom: 5px;
            }

            #select-screen h2 {
                font-size: 24px;
                margin-top: 20px;
            }
        }

        #kb-hint {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #666;
            font-size: 10px;
            pointer-events: none;
            display: none;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="game-container"></div>
    <div id="ui-layer">
        <div class="hud-top" id="hud" style="display:none;">
            <div class="health-bar-wrapper">
                <div class="health-bar-bg">
                    <div id="p1-hp" class="health-bar-fill hp-p1"></div>
                </div>
                <div class="gauge-bar-wrapper">
                    <div id="p1-gauge" class="gauge-bar-fill"></div>
                </div>
                <div class="name-label" style="text-align:right;">YOU</div>
            </div>
            <div class="round-badge">
                <div id="round-display">VS</div>
                <div id="level-display" style="font-size:12px; color:#aaa;">Lv.1</div>
            </div>
            <div class="health-bar-wrapper">
                <div class="health-bar-bg">
                    <div id="p2-hp" class="health-bar-fill hp-p2"></div>
                </div>
                <div class="gauge-bar-wrapper">
                    <div id="p2-gauge" class="gauge-bar-fill"></div>
                </div>
                <div class="name-label" id="enemy-name">CPU</div>
            </div>
        </div>
        <div id="controls-area" style="display:none;">
            <div class="control-zone" id="joystick-zone">
                <div id="stick-base">
                    <div id="stick-knob"></div>
                </div>
            </div>
            <div class="control-zone" id="action-zone">
                <div class="btn-action" id="btn-guard">GRD<br>(C)</div>
                <div class="btn-action" id="btn-ult">ULT<br>(V)</div>
                <div class="btn-action" id="btn-sp">SP<br>(X)</div>
                <div class="btn-action" id="btn-dash">DSH<br>(Sft)</div>
                <div class="btn-action" id="btn-jump">JMP<br>(Spc)</div>
                <div class="btn-action" id="btn-atk">ATK<br>(Z)</div>
            </div>
        </div>
        <div id="kb-hint">PC操作: 矢印=移動 | Z=攻撃 | X=必殺 | C=ガード | Shift=ダッシュ | Space=ジャンプ | V=ULT</div>
    </div>
    <div id="title-screen" class="screen">
        <h1>NEKKEN<br><span style="font-size:20px; letter-spacing:2px;">REALISTIC MODE</span></h1>
        <button id="start-btn" class="btn-cyber">MISSION START</button>
    </div>
    <div id="select-screen" class="screen hidden">
        <h2>SELECT YOUR CHASSIS</h2>
        <div class="char-grid" id="char-grid"></div>
    </div>
    <div id="result-screen" class="screen hidden">
        <h1 id="result-msg">WIN</h1><button id="retry-btn" class="btn-cyber">NEXT STAGE</button>
    </div>

    <script>
        const Input = {
            x: 0, y: 0, attack: false, jump: false, special: false, dash: false, guard: false, ultimate: false,
            keys: {}, stick: { active: false, startX: 0, startY: 0, currX: 0, currY: 0, maxDist: 40 },
            init: function () {
                window.addEventListener('keydown', e => { this.keys[e.code] = true; if (e.code === 'KeyZ') this.attack = true; if (e.code === 'KeyX') this.special = true; if (e.code === 'Space') this.jump = true; if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') this.dash = true; if (e.code === 'KeyC') this.guard = true; if (e.code === 'KeyV') this.ultimate = true; });
                window.addEventListener('keyup', e => { this.keys[e.code] = false; if (e.code === 'KeyZ') this.attack = false; if (e.code === 'KeyX') this.special = false; if (e.code === 'Space') this.jump = false; if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') this.dash = false; if (e.code === 'KeyC') this.guard = false; if (e.code === 'KeyV') this.ultimate = false; });
                if (!('ontouchstart' in window)) document.getElementById('kb-hint').style.display = 'block';
                const stickBase = document.getElementById('stick-base'), stickKnob = document.getElementById('stick-knob'), zone = document.getElementById('joystick-zone');
                const handleMove = (clientX, clientY) => { if (!this.stick.active) return; const rect = stickBase.getBoundingClientRect(), centerX = rect.left + rect.width / 2, centerY = rect.top + rect.height / 2; let dx = clientX - centerX, dy = clientY - centerY, dist = Math.hypot(dx, dy); if (dist > this.stick.maxDist) { const r = this.stick.maxDist / dist; dx *= r; dy *= r; } stickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`; this.x = dx / this.stick.maxDist; this.y = dy / this.stick.maxDist; };
                const resetStick = () => { this.stick.active = false; this.x = 0; this.y = 0; stickKnob.style.transform = `translate(-50%, -50%)`; };
                zone.addEventListener('touchstart', e => { e.preventDefault(); this.stick.active = true; handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
                zone.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
                zone.addEventListener('touchend', resetStick); zone.addEventListener('mousedown', e => { this.stick.active = true; handleMove(e.clientX, e.clientY); });
                window.addEventListener('mousemove', e => { if (this.stick.active) handleMove(e.clientX, e.clientY); }); window.addEventListener('mouseup', resetStick);
                const bindBtn = (id, prop) => { const el = document.getElementById(id); const press = (e) => { if (e.type === 'touchstart') e.preventDefault(); this[prop] = true; el.classList.add('pressed'); }; const release = (e) => { if (e.type === 'touchend') e.preventDefault(); this[prop] = false; el.classList.remove('pressed'); }; el.addEventListener('touchstart', press, { passive: false }); el.addEventListener('touchend', release); el.addEventListener('mousedown', press); el.addEventListener('mouseup', release); el.addEventListener('mouseleave', release); el.addEventListener('touchcancel', release); };
                bindBtn('btn-atk', 'attack'); bindBtn('btn-jump', 'jump'); bindBtn('btn-sp', 'special'); bindBtn('btn-dash', 'dash'); bindBtn('btn-guard', 'guard'); bindBtn('btn-ult', 'ultimate');
                window.addEventListener('touchend', (e) => { if (e.touches.length === 0) this.reset(); });
            },
            reset: function () { this.x = 0; this.y = 0; this.attack = false; this.jump = false; this.special = false; this.dash = false; this.guard = false; this.ultimate = false; this.stick.active = false; document.querySelectorAll('.btn-action').forEach(b => b.classList.remove('pressed')); const k = document.getElementById('stick-knob'); if (k) k.style.transform = `translate(-50%, -50%)`; },
            update: function () { let kx = 0, ky = 0; if (this.keys['ArrowLeft']) kx -= 1; if (this.keys['ArrowRight']) kx += 1; if (this.keys['ArrowUp']) ky -= 1; if (this.keys['ArrowDown']) ky += 1; if (!this.stick.active) { this.x = kx; this.y = ky; } }
        };

        const GAME_STATE = { TITLE: 0, SELECT: 1, FIGHT: 2, END: 3 };
        let currentState = GAME_STATE.TITLE;
        let scene, camera, renderer, clock;
        let player, enemy;
        let particles = [], projectiles = [];
        let currentLevel = 0, retryCredits = 3;

        const PLAYER_CATS = [
            { name: "VORTEX", color: 0x221111, trim: 0xff8800, eye: 0xffd700, socks: false, pattern: 'sabi', speed: 1.0, power: 1.3, hpMulti: 1.1 },
            { name: "BLADE", color: 0xbbbbbb, trim: 0x111111, eye: 0xdfff00, socks: true, pattern: 'stripe', speed: 1.4, power: 0.9, hpMulti: 0.9 },
            { name: "CHROME", color: 0xffffff, trim: 0x00ffff, eye: 0x00ffff, socks: false, pattern: 'solid', speed: 1.0, power: 1.0, hpMulti: 1.0 },
            { name: "SHADOW", color: 0x111111, trim: 0x5500ff, eye: 0xff0000, socks: true, pattern: 'solid', speed: 1.2, power: 0.9, hpMulti: 0.9 }
        ];
        const ENEMY_CATS = [
            { name: "LV1: STRAY", color: 0x888888, trim: 0xaaaaaa, eye: 0x00ff00, socks: false, pattern: 'solid', speed: 0.8, power: 0.7, hpMulti: 0.8, aiLevel: 1 },
            { name: "LV2: GINGER", color: 0xffcc88, trim: 0xcc6600, eye: 0xffff00, socks: true, pattern: 'stripe', speed: 0.9, power: 0.8, hpMulti: 0.9, aiLevel: 2 },
            { name: "LV3: MOSS", color: 0x224422, trim: 0x44ff44, eye: 0x00ff00, socks: false, pattern: 'sabi', speed: 1.0, power: 1.0, hpMulti: 1.0, aiLevel: 3 },
            { name: "LV4: AQUA", color: 0x004488, trim: 0x00ffff, eye: 0x00ffff, socks: true, pattern: 'solid', speed: 1.1, power: 1.0, hpMulti: 1.0, aiLevel: 4 },
            { name: "LV5: VOLT", color: 0xffff00, trim: 0x222222, eye: 0xff0000, socks: false, pattern: 'stripe', speed: 1.4, power: 1.1, hpMulti: 1.2, aiLevel: 5 },
            { name: "LV6: MAGMA", color: 0x440000, trim: 0xff4400, eye: 0xffaa00, socks: false, pattern: 'sabi', speed: 1.1, power: 1.6, hpMulti: 1.2, aiLevel: 6 },
            { name: "LV7: PHANTOM", color: 0x220033, trim: 0xff00ff, eye: 0xff00ff, socks: true, pattern: 'stripe', speed: 1.4, power: 1.3, hpMulti: 1.3, aiLevel: 7 },
            { name: "LV8: BLADE-X", color: 0xaaaaaa, trim: 0x000000, eye: 0x00ffcc, socks: true, pattern: 'stripe', speed: 1.6, power: 1.3, hpMulti: 1.3, aiLevel: 8 },
            { name: "LV9: VORTEX-Z", color: 0x110000, trim: 0xffaa00, eye: 0xff0000, socks: false, pattern: 'sabi', speed: 1.3, power: 1.6, hpMulti: 1.4, aiLevel: 9, infiniteBeams: true },
            { name: "LV10: GENESIS", color: 0xffffff, trim: 0xd4af37, eye: 0xffffff, socks: true, pattern: 'sabi', speed: 1.5, power: 1.8, hpMulti: 1.6, aiLevel: 10, infiniteBeams: true }
        ];
        let playerIdx = 0;

        const AudioSys = {
            ctx: null,
            init: function () { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            playTone: function (freq, type, dur, vol = 0.1) {
                if (!this.ctx) return; const t = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = type; osc.frequency.setValueAtTime(freq, t); osc.frequency.exponentialRampToValueAtTime(freq * 0.1, t + dur);
                g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.01, t + dur);
                osc.connect(g); g.connect(this.ctx.destination); osc.start(); osc.stop(t + dur);
            },
            // ★追加: 猫の鳴き声生成関数
            meow: function (isPain = false) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                osc.type = 'sawtooth'; // 倍音成分の多い波形で猫の声っぽく
                filter.type = 'lowpass';
                filter.frequency.value = 1000;

                const startFreq = isPain ? 500 + Math.random() * 200 : 300 + Math.random() * 150;
                const duration = isPain ? 0.2 : 0.4 + Math.random() * 0.3;

                osc.frequency.setValueAtTime(startFreq, t);
                // ピッチ変化: 上がって下がる (ニャ〜)
                osc.frequency.linearRampToValueAtTime(startFreq * 1.5, t + duration * 0.3);
                osc.frequency.linearRampToValueAtTime(startFreq * 0.8, t + duration);

                // 音量変化
                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.1, t + duration * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, t + duration);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(t);
                osc.stop(t + duration);
            },
            hit: () => AudioSys.playTone(150, 'square', 0.2, 0.2), swing: () => AudioSys.playTone(400, 'sawtooth', 0.1, 0.05),
            jump: () => AudioSys.playTone(300, 'sine', 0.2, 0.1), beam: () => AudioSys.playTone(600, 'square', 0.3, 0.1),
            dash: () => AudioSys.playTone(200, 'triangle', 0.1, 0.1), ultimate: () => AudioSys.playTone(800, 'square', 1.0, 0.3)
        };

        function init3D() {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x0a0a12); scene.fog = new THREE.FogExp2(0x0a0a12, 0.04);
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100); camera.position.set(0, 6, 14);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(container.clientWidth, container.clientHeight); renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            const amb = new THREE.AmbientLight(0x404040, 2.0); scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(5, 10, 5); dir.castShadow = true; scene.add(dir);
            const grid = new THREE.GridHelper(40, 40, 0x00ffff, 0x222222); scene.add(grid);
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ color: 0x050505 })); plane.rotation.x = -Math.PI / 2; plane.position.y = -0.1; scene.add(plane);
            clock = new THREE.Clock();
            window.addEventListener('resize', () => { camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(container.clientWidth, container.clientHeight); });
        }

        function createCatTexture(baseColorHex, trimColorHex, patternType) {
            const size = 512;
            const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d');
            const baseColor = new THREE.Color(baseColorHex);
            const trimColor = new THREE.Color(trimColorHex);

            function drawFurNoise(ctx, color, density, opacity) {
                ctx.fillStyle = color;
                for (let i = 0; i < density; i++) {
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const len = 2 + Math.random() * 4;
                    const angle = (Math.random() - 0.5) * 0.5;
                    ctx.globalAlpha = Math.random() * opacity;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.sin(angle) * len, y + Math.cos(angle) * len);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 0.5 + Math.random();
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;
            }

            ctx.fillStyle = `#${baseColor.getHexString()}`;
            ctx.fillRect(0, 0, size, size);

            drawFurNoise(ctx, '#000000', 20000, 0.1);
            drawFurNoise(ctx, '#ffffff', 20000, 0.1);

            if (patternType === 'stripe') {
                const cHex = `#${trimColor.getHexString()}`;
                for (let i = 0; i < 15; i++) {
                    const basePathY = i * (size / 12);
                    for (let x = 0; x < size; x += 2) {
                        const yOffset = Math.sin(x * 0.02 + i) * 30 + Math.random() * 5;
                        const width = 10 + Math.sin(x * 0.05) * 5;
                        if (Math.random() > 0.3) {
                            ctx.strokeStyle = cHex;
                            ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            const furY = basePathY + yOffset + (Math.random() - 0.5) * width;
                            ctx.moveTo(x, furY);
                            ctx.lineTo(x + (Math.random() - 0.5) * 2, furY + 5 + Math.random() * 5);
                            ctx.stroke();
                        }
                    }
                }
            } else if (patternType === 'sabi') {
                const cHex = `#${trimColor.getHexString()}`;
                for (let i = 0; i < 60; i++) {
                    const cx = Math.random() * size;
                    const cy = Math.random() * size;
                    const r = 20 + Math.random() * 50;
                    for (let j = 0; j < 300; j++) {
                        const ang = Math.random() * Math.PI * 2;
                        const dist = Math.random() * r;
                        const px = cx + Math.cos(ang) * dist;
                        const py = cy + Math.sin(ang) * dist;
                        ctx.strokeStyle = cHex;
                        ctx.globalAlpha = 0.4 + Math.random() * 0.4;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(px, py + 4 + Math.random() * 4);
                        ctx.stroke();
                    }
                }
            }

            if (patternType !== 'solid') {
                drawFurNoise(ctx, `#${trimColor.getHexString()}`, 5000, 0.05);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            return texture;
        }
        // --- 強化された猫モデルクラス ---
        class Cat {
            constructor(data, isPlayer, startZ) {
                this.data = data;
                this.isPlayer = isPlayer;
                this.maxHp = 100 * data.hpMulti;
                this.hp = this.maxHp;
                this.maxGauge = 100;
                this.gauge = 0;
                this.beamCount = 3;
                this.state = 'idle';
                this.timer = 0;
                this.vy = 0;
                this.groundY = 0;
                this.invincible = 0;
                this.hasHit = false;
                this.dashVec = new THREE.Vector3();
                this.comboReady = false;
                this.forceApproach = false;
                this.consecutiveShots = 0;

                // ★追加: 鳴き声のタイマー
                this.meowTimer = Math.random() * 5 + 3;

                // コンテナ: 移動用
                this.mesh = new THREE.Group();
                this.mesh.position.set(0, 0, startZ);

                // コンテナ: モデルの向き補正用
                this.modelGroup = new THREE.Group();
                this.modelGroup.rotation.y = Math.PI;
                this.mesh.add(this.modelGroup);

                // Materials
                const texture = createCatTexture(data.color, data.trim, data.pattern);
                const bodyMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.6, metalness: 0.1 });
                const trimMat = new THREE.MeshStandardMaterial({ color: data.trim, roughness: 0.8 });
                const eyeColorMat = new THREE.MeshBasicMaterial({ color: data.eye });
                const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const socksMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
                const noseMat = new THREE.MeshStandardMaterial({ color: 0xffaaaa, roughness: 0.5 });
                const whiskerMat = new THREE.LineBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.6 });

                // --- リアル化: ジオメトリの変更 ---
                // BoxGeometryの代わりに、SphereやCylinderを使って有機的な形を作る

                // 腰 (Hips) - 骨盤周り
                this.hips = new THREE.Group();
                this.hips.position.y = 0.55;
                this.modelGroup.add(this.hips);

                // お腹 (Abdomen) - 少し太めの円柱または球
                // SphereGeometry(radius, widthSegments, heightSegments)
                const abdomenGeo = new THREE.SphereGeometry(0.28, 16, 12);
                abdomenGeo.scale(1, 0.9, 1.2); // 楕円にする
                this.abdomen = new THREE.Mesh(abdomenGeo, bodyMat);
                this.abdomen.position.z = 0.2;
                this.abdomen.castShadow = true;
                this.hips.add(this.abdomen);

                // 胸 (Chest) - お腹より少し大きい
                const chestGeo = new THREE.SphereGeometry(0.32, 16, 12);
                chestGeo.scale(1, 0.95, 1.1);
                this.chest = new THREE.Mesh(chestGeo, bodyMat);
                this.chest.position.set(0, 0.05, -0.45);
                this.chest.castShadow = true;
                this.abdomen.add(this.chest);

                // 頭 (Head) - 球体をベースに
                this.headGroup = new THREE.Group();
                this.headGroup.position.set(0, 0.25, -0.4);
                this.chest.add(this.headGroup);

                const headGeo = new THREE.SphereGeometry(0.24, 16, 16);
                headGeo.scale(1.1, 0.9, 1.0); // 少し平たく
                this.head = new THREE.Mesh(headGeo, bodyMat);
                this.headGroup.add(this.head);

                // マズル (Muzzle) - 小さな球か円柱
                const muzzleGeo = new THREE.SphereGeometry(0.12, 12, 8);
                muzzleGeo.scale(1, 0.8, 1);
                const muzzle = new THREE.Mesh(muzzleGeo, trimMat);
                muzzle.position.set(0, -0.08, -0.18);
                this.head.add(muzzle);

                // 鼻 (Nose) - 三角形
                const noseGeo = new THREE.ConeGeometry(0.03, 0.05, 3);
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.rotation.x = -Math.PI / 2;
                nose.rotation.z = Math.PI;
                nose.position.set(0, 0.08, -0.1);
                muzzle.add(nose);

                // ひげ (Whiskers) - ラインで表現
                const whiskerGroup = new THREE.Group();
                muzzle.add(whiskerGroup);
                for (let i = 0; i < 6; i++) {
                    const isRight = i < 3;
                    const points = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(isRight ? 0.3 : -0.3, (i % 3) * 0.05 - 0.05, 0)];
                    const wGeo = new THREE.BufferGeometry().setFromPoints(points);
                    const whisker = new THREE.Line(wGeo, whiskerMat);
                    whisker.position.set(isRight ? 0.05 : -0.05, 0, -0.05);
                    whiskerGroup.add(whisker);
                }

                // Eyes - 少しリアルな配置
                const eyeGeo = new THREE.SphereGeometry(0.06, 12, 8);
                eyeGeo.scale(1, 1, 0.5); // 扁平にする

                const eyeLGroup = new THREE.Group();
                eyeLGroup.position.set(-0.1, 0.02, -0.18);
                eyeLGroup.rotation.y = -0.3;
                this.head.add(eyeLGroup);
                const eyeL = new THREE.Mesh(eyeGeo, eyeColorMat);
                eyeLGroup.add(eyeL);

                const pupilGeo = new THREE.SphereGeometry(0.03, 8, 8);
                pupilGeo.scale(0.5, 1, 0.2);
                const pupilL = new THREE.Mesh(pupilGeo, pupilMat);
                pupilL.position.z = -0.05;
                eyeL.add(pupilL);

                const eyeRGroup = new THREE.Group();
                eyeRGroup.position.set(0.1, 0.02, -0.18);
                eyeRGroup.rotation.y = 0.3;
                this.head.add(eyeRGroup);
                const eyeR = new THREE.Mesh(eyeGeo, eyeColorMat);
                eyeRGroup.add(eyeR);
                const pupilR = new THREE.Mesh(pupilGeo, pupilMat);
                pupilR.position.z = -0.05;
                eyeR.add(pupilR);

                // Ears - 三角錐だが、位置を調整
                const earGeo = new THREE.ConeGeometry(0.08, 0.2, 4);
                const earL = new THREE.Mesh(earGeo, bodyMat);
                earL.position.set(-0.15, 0.2, -0.05);
                earL.rotation.z = 0.3;
                earL.rotation.y = -0.2;
                earL.rotation.x = -0.2;
                this.head.add(earL);

                const earR = new THREE.Mesh(earGeo, bodyMat);
                earR.position.set(0.15, 0.2, -0.05);
                earR.rotation.z = -0.3;
                earR.rotation.y = 0.2;
                earR.rotation.x = -0.2;
                this.head.add(earR);

                // Tail - 球の連なりで滑らかに
                this.tail = [];
                let parent = this.abdomen;
                for (let i = 0; i < 5; i++) { // セグメント数を増やして滑らかに
                    const tGroup = new THREE.Group();
                    // 接続位置調整
                    if (i === 0) tGroup.position.set(0, 0.15, 0.35); else tGroup.position.set(0, 0, 0.18);

                    // Sphere or Cylinder
                    const tSize = 0.08 - i * 0.01;
                    const tGeo = new THREE.CylinderGeometry(tSize, tSize * 0.8, 0.2, 8);
                    tGeo.rotateX(Math.PI / 2);
                    const tMesh = new THREE.Mesh(tGeo, bodyMat);
                    tMesh.position.z = 0.1; // pivot offset
                    tGroup.add(tMesh);
                    parent.add(tGroup);
                    this.tail.push(tGroup);
                    parent = tGroup;
                }

                // Legs - 円柱 (Cylinder) に変更
                this.legs = [];
                const legData = [
                    { pos: [-0.22, -0.1, -0.3], parent: this.chest, isFront: true },
                    { pos: [0.22, -0.1, -0.3], parent: this.chest, isFront: true },
                    { pos: [-0.2, -0.1, 0.2], parent: this.abdomen, isFront: false },
                    { pos: [0.2, -0.1, 0.2], parent: this.abdomen, isFront: false }
                ];

                legData.forEach(d => {
                    const lGroup = new THREE.Group();
                    lGroup.position.set(d.pos[0], d.pos[1], d.pos[2]);
                    d.parent.add(lGroup);

                    // 太もも/上腕
                    const upperGeo = new THREE.CylinderGeometry(0.1, 0.07, 0.35, 8);
                    const upper = new THREE.Mesh(upperGeo, bodyMat);
                    upper.position.y = -0.15;
                    lGroup.add(upper);

                    const knee = new THREE.Group();
                    knee.position.y = -0.3;
                    upper.add(knee);

                    // すね/前腕
                    const lowerGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.3, 8);
                    const lower = new THREE.Mesh(lowerGeo, trimMat);
                    lower.position.y = -0.15;
                    if (!d.isFront) lower.rotation.x = 0.5; // 後ろ足の関節角度
                    knee.add(lower);

                    // 足先 (Paw) - 少し丸く
                    const pawGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.1, 8);
                    pawGeo.rotateX(Math.PI / 2); // 横倒し
                    const paw = new THREE.Mesh(pawGeo, data.socks ? socksMat : trimMat);
                    paw.scale.set(1, 1, 1.5); // 前後に長く
                    paw.position.set(0, -0.15, 0.05);
                    if (!d.isFront) paw.rotation.x = -0.5;
                    lower.add(paw);

                    this.legs.push({ root: lGroup, knee: knee, isFront: d.isFront });
                });

                scene.add(this.mesh);
            }

            // 更新処理 (フレームごと)
            update(dt) {
                // 無敵時間処理 (点滅)
                if (this.invincible > 0) {
                    this.invincible -= dt;
                    this.mesh.visible = Math.floor(this.invincible * 20) % 2 === 0;
                } else { this.mesh.visible = true; }

                // ★追加: ランダムで鳴く処理
                if (this.meowTimer > 0) {
                    this.meowTimer -= dt;
                    if (this.meowTimer <= 0) {
                        if (Math.random() < 0.4) { // 40%の確率で鳴く
                            AudioSys.meow();
                        }
                        this.meowTimer = Math.random() * 8 + 4; // 次の判定まで4~12秒
                    }
                }

                // 重力と着地
                if (this.mesh.position.y > this.groundY || this.vy > 0) {
                    this.vy -= 20 * dt;
                    this.mesh.position.y += this.vy * dt;
                    if (this.mesh.position.y <= this.groundY) {
                        this.mesh.position.y = this.groundY;
                        this.vy = 0;

                        // stateがジャンプ系なら着地処理
                        if (this.state === 'jump') {
                            this.toState('idle');
                        } else if (this.state === 'jump_attack') {
                            // ★修正: ジャンプ攻撃後は着地硬直へ移行
                            this.toState('land_lag');
                        } else if (this.state === 'dive') {
                            this.toState('land_lag');
                        }
                    }
                }

                // 地面より下にいかないようにクランプ
                if (this.mesh.position.y < this.groundY) {
                    this.mesh.position.y = this.groundY;
                    this.vy = 0;
                    if (['jump', 'dive', 'jump_attack'].includes(this.state)) {
                        if (this.state === 'jump') this.toState('idle');
                        else this.toState('land_lag'); // ダイブ/ジャンプ攻撃は硬直あり
                    }
                }

                // タイマー処理 (アクションの継続時間など)
                if (this.timer > 0) {
                    this.timer -= dt;
                    if (this.timer <= 0) {
                        // ★修正: 'guard' もタイマー終了でidleに戻る対象に追加 (AI用)
                        if (['attack', 'special', 'hit', 'dash', 'dive', 'jump_attack', 'ultimate', 'land_lag', 'guard'].includes(this.state)) {
                            this.toState('idle');
                        }
                    }
                }

                // ダッシュ・ダイブの座標移動
                if (this.state === 'dash') {
                    this.mesh.position.add(this.dashVec.clone().multiplyScalar(dt));
                    if (Math.random() < 0.3) spawnParticles(this.mesh.position, 0xffffff);
                } else if (this.state === 'dive') {
                    const diveSpeed = 15.0;
                    const dir = this.target.mesh.position.clone().sub(this.mesh.position).normalize();
                    dir.y = -1.0;
                    this.mesh.position.add(dir.multiplyScalar(diveSpeed * dt));
                }

                const t = clock.elapsedTime * 10;
                this.mesh.rotation.y = (this.target && this.state !== 'special' && this.state !== 'ultimate') ? 0 : this.mesh.rotation.y;

                // ★修正箇所: アニメーションの基本姿勢リセットを完全に行う
                this.hips.position.set(0, 0.55, 0);

                this.hips.rotation.z = 0;
                this.abdomen.rotation.x = 0;
                this.chest.rotation.x = 0;

                if (this.state === 'run') {
                    this.hips.position.y = 0.55 + Math.sin(t * 2) * 0.05;
                    this.abdomen.rotation.x = Math.sin(t * 1.5) * 0.1;
                    this.legs.forEach((l, i) => {
                        const offset = i % 2 === 0 ? 0 : Math.PI;
                        l.root.rotation.x = Math.sin(t + offset) * 0.8;
                        l.knee.rotation.x = Math.abs(Math.sin(t + offset)) * 1.0;
                    });
                    this.tail.forEach((seg, i) => seg.rotation.y = Math.sin(t * 0.8 - i) * 0.3);

                } else if (this.state === 'idle') {
                    this.hips.position.y = 0.55 + Math.sin(t * 0.5) * 0.02;
                    this.legs.forEach(l => {
                        l.root.rotation.x = 0;
                        l.knee.rotation.x = l.isFront ? 0 : 0.2;
                    });
                    this.tail.forEach((seg, i) => seg.rotation.y = Math.sin(t * 0.2 - i) * 0.1);

                } else if (this.state === 'attack') {
                    // ★修正箇所: 攻撃時の踏み込みを「加算」ではなく「一時的なオフセット」に変更
                    const lungAmount = Math.sin(Math.PI * (1 - this.timer / 0.3)) * 0.2;
                    this.hips.position.z += lungAmount;

                    this.chest.rotation.x = -0.2;
                    this.legs[1].root.rotation.x = -1.0 * Math.sin(Math.PI * (1 - this.timer / 0.3));

                } else if (this.state === 'special') {
                    this.mesh.rotation.y += 0.5;
                    this.tail.forEach(seg => seg.rotation.x = 0.5);

                } else if (this.state === 'dash') {
                    this.hips.position.y = 0.4;
                    this.legs.forEach(l => l.root.rotation.x = 1.0);

                } else if (this.state === 'guard') {
                    this.chest.rotation.x = 0.3;
                    this.headGroup.rotation.x = 0.2;

                } else if (this.state === 'jump' || this.state === 'jump_attack') {
                    this.legs.forEach(l => {
                        l.root.rotation.x = 0.5;
                        l.knee.rotation.x = -1.0;
                    });
                } else if (this.state === 'dive') {
                    this.modelGroup.rotation.x = 0.5;
                    this.legs[1].root.rotation.x = -1.5;
                } else if (this.state === 'land_lag') {
                    // 着地硬直: 少し沈み込む
                    this.hips.position.y = 0.4;
                    this.legs.forEach(l => {
                        l.root.rotation.x = 0.5;
                        l.knee.rotation.x = 0.8;
                    });
                } else if (this.state === 'ultimate') {
                    this.mesh.rotation.y += 1.0;
                    this.mesh.scale.setScalar(1.0 + Math.sin(t * 5) * 0.2);
                }

                if (this.state !== 'ultimate') this.mesh.scale.setScalar(1);
                if (this.state !== 'dive') this.modelGroup.rotation.x = 0;

                if (['special', 'ultimate', 'jump_attack', 'dive', 'land_lag'].includes(this.state)) {
                    // これらの状態では向き補正しない
                } else {
                    if (this.target) {
                        const targetPos = this.target.mesh.position.clone();
                        targetPos.y = this.mesh.position.y;
                        this.mesh.lookAt(targetPos);
                    }
                }
                if (this.mesh.position.length() > 20) this.mesh.position.setLength(20);
            }

            // 状態遷移
            toState(s) {
                this.state = s;
                if (s === 'attack') {
                    this.timer = 0.3; this.hasHit = false; AudioSys.swing();
                } else if (s === 'special') {
                    if (!this.data.infiniteBeams) { if (this.beamCount > 0) this.beamCount--; }
                    this.timer = 0.8; this.hasHit = false; this.vy = 5; AudioSys.swing();
                } else if (s === 'jump') {
                    this.vy = 15; AudioSys.jump(); this.hasHit = false;
                } else if (s === 'hit') {
                    this.timer = 0.4;
                } else if (s === 'dash') {
                    this.timer = 0.2; this.vy = 0; AudioSys.dash();
                } else if (s === 'guard') {
                    // ★修正: AIの場合は時間経過でガード解除 (例: 0.5秒〜1.0秒)
                    // プレイヤー(isPlayer)は0にしておき、ボタン離しで解除するロジックに任せる
                    this.timer = this.isPlayer ? 0 : 0.5 + Math.random() * 0.5;
                } else if (s === 'jump_attack') {
                    this.timer = 0.4; this.hasHit = false; AudioSys.swing();
                } else if (s === 'dive') {
                    this.timer = 1.0; this.hasHit = false; this.vy = 0; AudioSys.swing();
                } else if (s === 'land_lag') {
                    this.timer = 0.5; // 着地硬直時間 (0.5秒)
                    this.hasHit = false;
                } else if (s === 'ultimate') {
                    this.timer = 1.5; this.hasHit = false; this.gauge = 0; AudioSys.ultimate();
                    spawnParticles(this.mesh.position, 0xff00ff);
                }
            }

            takeDamage(amount) {
                if (this.invincible > 0) return;

                if (this.state === 'guard') {
                    amount *= 0.2;
                    this.gauge += 5;

                    // ★修正: ゲージMAXでビーム補充 (プレイヤーのみ)
                    if (this.gauge >= this.maxGauge) {
                        this.gauge = this.maxGauge;
                        if (this.isPlayer && this.beamCount < 3) {
                            this.beamCount = 3;
                            // 補充音 or エフェクト (AudioSysにreloadがあれば呼ぶが、無いのでcharge等を代用検討、今回は割愛または既存音)
                        }
                    }

                    spawnParticles(this.mesh.position, 0x0088ff);
                    this.hp -= amount;
                    updateHUD();
                    if (this.hp <= 0) { this.hp = 0; endRound(this.isPlayer); }
                    return;
                }

                this.hp -= amount;
                this.gauge += 10;
                // ★追加: ダメージを受けた時に悲鳴（鳴き声）
                AudioSys.meow(true);

                // ★修正: ゲージMAXでビーム補充 (プレイヤーのみ)
                if (this.gauge >= this.maxGauge) {
                    this.gauge = this.maxGauge;
                    if (this.isPlayer && this.beamCount < 3) {
                        this.beamCount = 3;
                    }
                }

                if (this.gauge > this.maxGauge) this.gauge = this.maxGauge;
                this.invincible = 1.0;
                this.toState('hit');
                const dir = this.mesh.position.clone().sub(this.target.mesh.position);
                dir.y = 0; dir.normalize();
                this.mesh.position.add(dir.multiplyScalar(2));
                this.mesh.position.y = Math.max(this.mesh.position.y, 0.5);
                spawnParticles(this.mesh.position, 0xff0000);
                AudioSys.hit();
                updateHUD();
                if (this.hp <= 0) { this.hp = 0; endRound(this.isPlayer); }
            }
        }

        // 飛び道具クラス
        class Projectile {
            constructor(owner) {
                this.owner = owner;
                const geo = new THREE.CylinderGeometry(0.2, 0.2, 2, 8); geo.rotateX(Math.PI / 2);
                this.mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                this.mesh.position.copy(owner.mesh.position); this.mesh.position.y = 1.0;
                this.mesh.lookAt(owner.target.mesh.position.x, 1.0, owner.target.mesh.position.z);
                this.dir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.mesh.quaternion);
                this.speed = 15; this.life = 2.0;
                scene.add(this.mesh);
            }
            update(dt) {
                this.life -= dt; this.mesh.position.add(this.dir.clone().multiplyScalar(this.speed * dt));
                const targetPos = this.owner.target.mesh.position;
                const dx = this.mesh.position.x - targetPos.x; const dz = this.mesh.position.z - targetPos.z;
                const distXZ = Math.sqrt(dx * dx + dz * dz);
                const isJumpDodged = targetPos.y > 1.3;
                if (distXZ < 1.5 && !isJumpDodged) { this.owner.target.takeDamage(15); this.life = 0; }
                if (this.life <= 0) { scene.remove(this.mesh); return false; }
                return true;
            }
        }

        function spawnParticles(pos, color) {
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            for (let i = 0; i < 8; i++) {
                const mesh = new THREE.Mesh(geo, mat); mesh.position.copy(pos); mesh.position.y += 0.5;
                scene.add(mesh);
                particles.push({ mesh: mesh, vel: new THREE.Vector3((Math.random() - 0.5), Math.random(), (Math.random() - 0.5)).multiplyScalar(0.2), life: 1.0 });
            }
        }

        let inputLock = { attack: false, special: false, ultimate: false, jump: false, dash: false, guard: false };

        function resolveCollision(c1, c2) {
            const p1 = c1.mesh.position;
            const p2 = c2.mesh.position;

            const dx = p1.x - p2.x;
            const dz = p1.z - p2.z;
            const distSq = dx * dx + dz * dz;
            const minDist = 1.5;

            const dy = Math.abs(p1.y - p2.y);

            if (distSq < minDist * minDist && dy < 2.0) {
                const dist = Math.sqrt(distSq);
                const overlap = minDist - dist;
                const nx = (dist > 0.01) ? dx / dist : 1;
                const nz = (dist > 0.01) ? dz / dist : 0;

                const pushX = nx * overlap * 0.5;
                const pushZ = nz * overlap * 0.5;

                c1.mesh.position.x += pushX;
                c1.mesh.position.z += pushZ;
                c2.mesh.position.x -= pushX;
                c2.mesh.position.z -= pushZ;
            }
        }

        // ゲームのメインループ更新
        function updateGame(dt) {
            Input.update();
            // 入力ロックの解除制御
            if (!Input.attack) inputLock.attack = false; if (!Input.special) inputLock.special = false;
            if (!Input.ultimate) inputLock.ultimate = false; if (!Input.jump) inputLock.jump = false; if (!Input.dash) inputLock.dash = false;

            // ガード解除
            if (player.state === 'guard' && !Input.guard) { player.state = 'idle'; }
            const canAct = (player.state === 'idle' || player.state === 'run' || player.state === 'guard');

            // プレイヤーの移動制御
            if (player.state === 'idle' || player.state === 'run' || player.state === 'jump') {
                const speed = 6.0 * player.data.speed;
                let moving = false;
                const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); fwd.y = 0; fwd.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion); right.y = 0; right.normalize();

                // スティック/キー入力がある場合
                if (Math.abs(Input.y) > 0.1 || Math.abs(Input.x) > 0.1) {
                    const moveDir = fwd.clone().multiplyScalar(-Input.y).add(right.clone().multiplyScalar(Input.x));

                    // ダッシュ (Shift/ボタン)
                    if (Input.dash && !inputLock.dash && player.gauge >= 10 && player.state !== 'dash' && player.state !== 'jump') {
                        inputLock.dash = true; player.toState('dash'); player.gauge -= 10;
                        let dDir = moveDir.clone();
                        if (dDir.lengthSq() === 0) { dDir = new THREE.Vector3(0, 0, 1).applyQuaternion(player.mesh.quaternion); }
                        dDir.normalize().multiplyScalar(speed * 8); player.dashVec.copy(dDir);
                    } else {
                        // 通常移動
                        player.mesh.position.add(moveDir.multiplyScalar(speed * dt)); moving = true;
                    }
                }
                if (player.state === 'idle' && moving) player.state = 'run';
                if (player.state === 'run' && !moving) player.state = 'idle';
            }

            // プレイヤーのアクション入力
            if (Input.ultimate && !inputLock.ultimate && player.gauge >= 100 && canAct) { inputLock.ultimate = true; player.toState('ultimate'); }
            else if (Input.special && !inputLock.special && canAct && player.beamCount > 0) { inputLock.special = true; player.toState('special'); projectiles.push(new Projectile(player)); AudioSys.beam(); }
            else if (Input.attack && !inputLock.attack) {
                if (player.state === 'jump') { if (!player.hasHit) { inputLock.attack = true; player.toState('dive'); } }
                else if (canAct) { inputLock.attack = true; player.toState('attack'); }
            }
            else if (Input.guard && canAct) { if (player.state !== 'guard') player.toState('guard'); }
            else if (Input.jump && !inputLock.jump && canAct && player.mesh.position.y <= 0.1) { inputLock.jump = true; player.toState('jump'); }

            // AI ロジック (敵の頭脳)
            if (enemy.state === 'idle' || enemy.state === 'run') {
                if (enemy.comboReady && enemy.state === 'idle') {
                    if (enemy.beamCount > 0 || enemy.data.infiniteBeams) {
                        enemy.toState('special'); projectiles.push(new Projectile(enemy)); AudioSys.beam();
                        enemy.comboReady = false; return;
                    }
                    enemy.comboReady = false;
                }
                const dist = enemy.mesh.position.distanceTo(player.mesh.position);
                const aiLevel = enemy.data.aiLevel || 1;
                const isBossTier = aiLevel >= 9;

                // 強制接近モード
                if (enemy.forceApproach) {
                    if (dist < 2.0) { enemy.forceApproach = false; enemy.consecutiveShots = 0; }
                    else {
                        const dir = player.mesh.position.clone().sub(enemy.mesh.position).normalize();
                        enemy.mesh.position.add(dir.multiplyScalar(enemy.data.speed * 4 * dt)); enemy.state = 'run';
                    }
                }

                // ★対空意識の追加: プレイヤーが飛んでいる場合
                let reactingToJump = false;
                if ((player.state === 'jump' || player.state === 'jump_attack' || player.state === 'dive') && aiLevel >= 3) {
                    // プレイヤーが飛んできたら
                    const jumpReactionChance = 0.1 + (aiLevel * 0.05); // レベルが高いほど反応
                    if (Math.random() < jumpReactionChance && dist < 5.0) {
                        reactingToJump = true;
                        // 下がってスカす、またはガード
                        if (enemy.gauge >= 10 && Math.random() < 0.5) {
                            // バックダッシュ
                            const backDir = enemy.mesh.position.clone().sub(player.mesh.position).normalize();
                            enemy.dashVec.copy(backDir.multiplyScalar(enemy.data.speed * 8));
                            enemy.toState('dash'); enemy.gauge -= 10;
                        } else {
                            // ガード待機 (次のフレームで攻撃が来たら防げるように)
                            enemy.toState('guard');
                        }
                    }
                }

                if (!enemy.forceApproach && !reactingToJump) {
                    let dir = player.mesh.position.clone().sub(enemy.mesh.position).normalize();
                    if (aiLevel >= 2) {
                        // 揺らぎ移動
                        const side = new THREE.Vector3(dir.z, 0, -dir.x);
                        const sway = Math.sin(clock.getElapsedTime() * 2.0 + aiLevel) * 0.8;
                        dir.add(side.multiplyScalar(sway * 0.5)).normalize();
                    }
                    let defensiveAction = false;

                    // 防御行動判定
                    // 1. ダッシュやダイブなどに対する回避
                    if (aiLevel >= 4 && (player.state === 'attack' || player.state === 'special' || player.state === 'dive' || player.state === 'dash')) {
                        // ★Lv4修正: 通常攻撃に対してもガードを行う
                        if (player.state === 'attack' && dist < 2.5) {
                            const blockChance = 0.3 + (aiLevel - 4) * 0.1; // Lv4=30%, Lv5=40%, ... Lv10=90%
                            if (Math.random() < blockChance) {
                                enemy.toState('guard');
                                defensiveAction = true;
                            }
                        }

                        // 既存の回避ロジック
                        if (!defensiveAction && dist < 4.5) {
                            const reactProb = 0.2 + (aiLevel * 0.1);
                            if (Math.random() < reactProb) {
                                if (aiLevel >= 6 && Math.random() < 0.6 && enemy.gauge > 10) {
                                    // 回避ダッシュ
                                    const dodgeDir = new THREE.Vector3(dir.z, 0, -dir.x).multiplyScalar(Math.random() < 0.5 ? 1 : -1);
                                    if (Math.random() < 0.3) dodgeDir.copy(dir).negate();
                                    enemy.dashVec.copy(dodgeDir.normalize().multiplyScalar(enemy.data.speed * 48));
                                    enemy.toState('dash'); enemy.gauge -= 10;
                                    if (aiLevel >= 7 && (enemy.beamCount > 0 || enemy.data.infiniteBeams) && Math.random() < 0.7) { enemy.comboReady = true; }
                                    defensiveAction = true;
                                } else {
                                    // 通常移動回避
                                    const side = new THREE.Vector3(dir.z, 0, -dir.x).multiplyScalar(Math.random() < 0.5 ? 1 : -1);
                                    dir.negate().add(side.multiplyScalar(0.8)).normalize();
                                    enemy.mesh.position.add(dir.multiplyScalar(enemy.data.speed * 6 * dt));
                                    defensiveAction = true;
                                }
                            }
                        }
                    }

                    // 攻撃行動判定
                    if (!defensiveAction) {
                        let aggression = 0.01 + (aiLevel * 0.005); if (isBossTier) aggression *= 1.5;
                        if (aiLevel >= 7 && dist < 1.5 && Math.random() < 0.05) { dir.negate(); } // フェイント

                        // ★Lv5修正: 戦略的後退 (ビームを撃つために距離を取る)
                        if (aiLevel >= 5 && (enemy.beamCount > 0 || enemy.data.infiniteBeams) && dist < 6.0 && dist > 2.5) {
                            // 30%の確率で少し下がる
                            if (Math.random() < 0.02) { // 毎フレーム抽選なので低確率にする
                                dir.negate();
                            }
                        }

                        if (Math.random() < aggression) {
                            // 遠距離攻撃
                            const beamRangeTrigger = isBossTier ? 4.0 : 3.0; // ボスは遠くても撃つ
                            if ((dist > beamRangeTrigger || (aiLevel >= 5 && dist > 3.0)) && !enemy.forceApproach) {
                                // Lv5以上なら積極的にビームを使う
                                let shootProb = 0.3;
                                if (aiLevel >= 5 && enemy.beamCount > 0) shootProb = 0.6;

                                if (enemy.consecutiveShots < 3 && Math.random() < shootProb) {
                                    enemy.toState('special'); projectiles.push(new Projectile(enemy)); AudioSys.beam();
                                    enemy.consecutiveShots++; if (enemy.consecutiveShots >= 3) enemy.forceApproach = true; return;
                                }
                            }
                            if (dist > 2.2) {
                                if (isBossTier && !enemy.forceApproach && enemy.consecutiveShots < 3 && Math.random() < 0.3) {
                                    enemy.toState('special'); projectiles.push(new Projectile(enemy)); AudioSys.beam();
                                    enemy.consecutiveShots++; if (enemy.consecutiveShots >= 3) enemy.forceApproach = true;
                                } else {
                                    // 接近
                                    enemy.mesh.position.add(dir.multiplyScalar(enemy.data.speed * 4 * dt)); enemy.state = 'run';
                                }
                            } else {
                                // 近接戦闘
                                const roll = Math.random();
                                if (roll < 0.6) enemy.toState('attack');
                                else if (roll < 0.75 && (enemy.beamCount > 0 || enemy.data.infiniteBeams) && aiLevel > 2) {
                                    enemy.toState('special'); projectiles.push(new Projectile(enemy)); AudioSys.beam();
                                }
                                else if (roll < 0.85 && enemy.gauge >= 100 && aiLevel > 5) enemy.toState('ultimate');
                                else enemy.toState('jump');
                            }
                        } else {
                            // 位置調整
                            if (dist > 2.0 || (aiLevel >= 2 && dist > 1.5)) { enemy.mesh.position.add(dir.multiplyScalar(enemy.data.speed * 4 * dt)); enemy.state = 'run'; }
                            else { enemy.state = 'idle'; }
                        }
                    }
                }
            }

            player.update(dt); enemy.update(dt);
            resolveCollision(player, enemy);
            checkHit(player, enemy); checkHit(enemy, player);

            // 弾丸の更新
            for (let i = projectiles.length - 1; i >= 0; i--) { if (!projectiles[i].update(dt)) projectiles.splice(i, 1); }
            // パーティクルの更新
            for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.life -= dt * 2; p.mesh.position.add(p.vel); p.mesh.rotation.x += dt; if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); } }

            // カメラ追従
            const mid = player.mesh.position.clone().add(enemy.mesh.position).multiplyScalar(0.5); const dist = player.mesh.position.distanceTo(enemy.mesh.position);
            const camTargetPos = new THREE.Vector3(mid.x, 5 + dist * 0.3, mid.z + 8 + dist * 0.5); camera.position.lerp(camTargetPos, 0.05); camera.lookAt(mid);
            updateHUD();
        }

        function checkHit(atk, def) {
            if ((atk.state === 'attack' || atk.state === 'jump_attack' || atk.state === 'ultimate' || atk.state === 'dive') && !atk.hasHit) {
                const dist = atk.mesh.position.distanceTo(def.mesh.position);
                if (dist < 2.0) {
                    atk.hasHit = true;
                    let dmg = 8;
                    if (atk.state === 'jump_attack') dmg = 12;
                    if (atk.state === 'ultimate') dmg = 40;
                    if (atk.state === 'dive') dmg = 15;
                    dmg *= atk.data.power;
                    def.takeDamage(dmg);
                }
            }
        }

        function startGame() {
            AudioSys.init(); document.getElementById('title-screen').classList.add('hidden'); document.getElementById('select-screen').classList.remove('hidden');
            const grid = document.getElementById('char-grid'); grid.innerHTML = '';
            PLAYER_CATS.forEach((cat, i) => {
                const d = document.createElement('div'); d.className = 'char-card';
                const spdPct = Math.min(100, cat.speed * 50); const pwrPct = Math.min(100, cat.power * 50);
                d.innerHTML = `
                    <div class="char-preview-box" style="background:#${new THREE.Color(cat.color).getHexString()}; border-color:#${new THREE.Color(cat.trim).getHexString()};">
                        <div style="width:100%; height:100%; border-radius:50%; box-shadow: inset 0 0 20px rgba(0,0,0,0.8);"></div>
                        <div style="position:absolute; top:35%; left:20%; width:15px; height:10px; background:#${new THREE.Color(cat.eye).getHexString()}; border-radius:50%; box-shadow:0 0 5px #${new THREE.Color(cat.eye).getHexString()};"></div>
                        <div style="position:absolute; top:35%; right:20%; width:15px; height:10px; background:#${new THREE.Color(cat.eye).getHexString()}; border-radius:50%; box-shadow:0 0 5px #${new THREE.Color(cat.eye).getHexString()};"></div>
                    </div>
                    <div class="char-name" style="color:#${new THREE.Color(cat.trim).getHexString()}; text-shadow:0 0 5px #${new THREE.Color(cat.trim).getHexString()}">${cat.name}</div>
                    <div class="stat-row"><span class="stat-label">SPD</span><div class="stat-bar-bg"><div class="stat-bar-fill spd-fill" style="width:${spdPct}%"></div></div></div>
                    <div class="stat-row"><span class="stat-label">PWR</span><div class="stat-bar-bg"><div class="stat-bar-fill pwr-fill" style="width:${pwrPct}%"></div></div></div>
                `;
                d.onclick = () => { document.querySelectorAll('.char-card').forEach(c => c.classList.remove('active')); d.classList.add('active'); setTimeout(() => { playerIdx = i; currentLevel = 0; retryCredits = 3; document.getElementById('select-screen').classList.add('hidden'); startMatch(); }, 500); };
                grid.appendChild(d);
            });
        }

        function startMatch() {
            if (player) { scene.remove(player.mesh); scene.remove(enemy.mesh); }
            projectiles.forEach(p => scene.remove(p.mesh)); projectiles = []; particles.forEach(p => scene.remove(p.mesh)); particles = [];
            Input.reset(); inputLock.attack = false; inputLock.special = false; inputLock.ultimate = false; inputLock.jump = false; inputLock.dash = false;

            player = new Cat(PLAYER_CATS[playerIdx], true, 5);
            const enemyData = ENEMY_CATS[Math.min(currentLevel, ENEMY_CATS.length - 1)];

            // ★Lv6以上でビーム弾数増加: Lv5までは3発、Lv6で5発、Lv7で7発... (3 + (lvl-5)*2)
            enemy = new Cat(enemyData, false, -5);
            if (!enemy.data.infiniteBeams) {
                const currentEnemyLvl = enemy.data.aiLevel || 1;
                if (currentEnemyLvl >= 6) {
                    enemy.beamCount = 3 + (currentEnemyLvl - 5) * 2;
                }
            }

            player.target = enemy; enemy.target = player;
            document.getElementById('hud').style.display = 'flex'; document.getElementById('controls-area').style.display = 'flex'; document.getElementById('result-screen').classList.add('hidden');
            document.getElementById('level-display').innerText = "Lv." + (currentLevel + 1);
            updateHUD(); currentState = GAME_STATE.FIGHT;
        }

        function updateHUD() {
            const p1pct = (player.hp / player.maxHp) * 100; const p2pct = (enemy.hp / enemy.maxHp) * 100;
            document.getElementById('p1-hp').style.width = Math.max(0, p1pct) + '%'; document.getElementById('p2-hp').style.width = Math.max(0, p2pct) + '%';
            document.getElementById('p1-gauge').style.width = Math.min(100, player.gauge) + '%'; document.getElementById('p2-gauge').style.width = Math.min(100, enemy.gauge) + '%';
            document.getElementById('enemy-name').innerText = enemy.data.name;
            const spBtn = document.getElementById('btn-sp'); spBtn.innerHTML = `SP<br>(X)<br><span style="font-size:10px; color:${player.beamCount > 0 ? '#ffff00' : '#888'}">Rem:${player.beamCount}</span>`;
            if (player.beamCount <= 0) { spBtn.classList.add('disabled'); } else { spBtn.classList.remove('disabled'); }
        }

        function endRound(playerLost) {
            currentState = GAME_STATE.END;
            setTimeout(() => {
                document.getElementById('hud').style.display = 'none'; document.getElementById('controls-area').style.display = 'none'; const scr = document.getElementById('result-screen'); scr.classList.remove('hidden');
                if (playerLost) {
                    retryCredits--;
                    if (retryCredits > 0) { document.getElementById('result-msg').innerText = "DEFEATED"; document.getElementById('result-msg').style.color = '#ff0055'; document.getElementById('retry-btn').innerText = `RETRY (残り${retryCredits}回)`; document.getElementById('retry-btn').onclick = startMatch; }
                    else { document.getElementById('result-msg').innerText = "GAME OVER"; document.getElementById('result-msg').style.color = '#555'; document.getElementById('retry-btn').innerText = "TITLE"; document.getElementById('retry-btn').onclick = () => { location.reload(); }; }
                } else {
                    currentLevel++;
                    if (currentLevel >= ENEMY_CATS.length) { document.getElementById('result-msg').innerText = "ALL CLEAR!!"; document.getElementById('result-msg').style.color = '#00ffff'; document.getElementById('retry-btn').innerText = "TITLE"; document.getElementById('retry-btn').onclick = () => { location.reload(); }; }
                    else { document.getElementById('result-msg').innerText = "WIN!!"; document.getElementById('result-msg').style.color = '#00ffff'; document.getElementById('retry-btn').innerText = "NEXT STAGE"; document.getElementById('retry-btn').onclick = startMatch; }
                }
            }, 1500);
        }

        function animate() { requestAnimationFrame(animate); const dt = clock.getDelta(); if (currentState === GAME_STATE.FIGHT) updateGame(dt); renderer.render(scene, camera); }
        window.onload = function () { init3D(); Input.init(); document.getElementById('start-btn').onclick = startGame; document.getElementById('retry-btn').onclick = startMatch; animate(); };
    </script>
</body>

</html>
